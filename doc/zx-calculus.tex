\documentclass[a4paper]{ltxdoc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Packages
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}
\usepackage[margin=3cm]{geometry}
\usepackage{calc}
\usepackage{tikz}
\usetikzlibrary{shadows,fit}
% \usetikzlibrary fails because file is not in current directory, lazy to setup TEXINPUTS
\makeatletter
  \input{../tikzlibraryzx-calculus.code.tex}
\makeatother
% Loads the great package that produces tikz-like manual (see also tikzcd for examples)
\input{pgfmanual-en-macros.tex} % Is supposed to be included in recent TeX distributions, but I get errors...
\usepackage{makeidx} % Produces an index of commands.
\makeindex % Useful or not index will be created
\usepackage[hidelinks]{hyperref}
\newcommand{\mylink}[2]{\href{#1}{#2}\footnote{\url{#1}}}
\usepackage{verbatim}
\usepackage{cleveref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Documentation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%%% Title: thanks tikzcd for the styling
\begin{center}
  \vspace*{1em} % Thanks tikzcd
  \tikz\node[scale=1.2]{%
    \color{gray}\Huge\ttfamily \char`\{\raisebox{.09em}{\textcolor{red!75!black}{zx\raisebox{-0.1em}{-}calculus}}\char`\}};

  \vspace{0.5em}
  {\Large\bfseries ZX-calculus with \tikzname}

  \vspace{1em}
  {Version 2021/10/22}\\[3mm]
  {\href{https://github.com/leo-colisson/zx-calculus}{\texttt{github.com/leo-colisson/zx-calculus}}}
\end{center}

\tableofcontents

\section{Introduction}

This library (based on the great \tikzname{} and \tikzname-cd packages) allows you to typeset ZX-calculus directly in \LaTeX{}. It comes with a default---but highly customizable---style:
\begin{codeexample}[]
  \begin{ZX}
    \zxZ{\alpha} \arrow[r] & \zxFracX-{\pi}{4}
  \end{ZX}
\end{codeexample}
Even if this has not yet been tested a lot, you can also use a ``phase in label'' style, without really changing the code:
\begin{codeexample}[]
  \begin{ZX}[phase in label right]
    \zxZ{\alpha} \arrow[d] \\
    \zxFracX-{\pi}{4}
  \end{ZX}
\end{codeexample}


The goal is to provide an alternative to the great |tikzit| package: we wanted a solution that does not require the creation of an additional file, the use of an external software, and which automatically adapts the width of columns and rows depending on the content of the nodes (in |tikzit| one needs to manually tune the position of each node, especially when dealing with large nodes). Our library also provides a default style and tries to separate the content from the style: that way it should be easy to globally change the styling of a given project without redesigning all diagrams. However, it should be fairly easy to combine tikzit and this library: when some diagrams are easier to design in tikzit, then it should be possible to directly load the style of this library inside tikzit.

This library is quite young, so feel free to propose improvements or report issues on \href{https://github.com/leo-colisson/zx-calculus/issues}{\texttt{github.com/leo-colisson/zx-calculus/issues}}. We will of course try to maintain backward compatibility as much as possible, but we can't guarantee at 100\% that small changes (spacing, wire looks\dots{}) won't be made later. In case you want a completely unalterable style, just copy the two files of this library in your project forever (see installation)!

\section{Installation}

If your CTAN distribution is recent enough, you can directly insert in your file:
% verse indents stuff, index adds to the index of command at the end of the file, || is a shortcut of \verb||
\begin{verse}
  \index{zx@\protect\texttt{zx-calculus} package}%
  \index{Packages and files!zx-calculus@\protect\texttt{zx-calculus}}%
  |\usepackage{zx-calculus}|%
\end{verse}
or load \tikzname{} and then use:
\begin{verse}%
   \index{cd@\protect\texttt{zx-calculus} library}%
   \index{Libraries!cd@\protect\texttt{zx-calculus}}%
   |\usetikzlibrary{zx-calculus}|%
\end{verse}
If this library is not yet packaged into CTAN (which is very likely in 2021), you must first download \mylink{https://github.com/leo-colisson/zx-calculus/blob/main/tikzlibraryzx-calculus.code.tex}{\texttt{tikzlibraryzx-calculus.code.tex}} and \mylink{https://github.com/leo-colisson/zx-calculus/blob/main/zx-calculus.sty}{\texttt{zx-calculus.sty}} (right-click on ``Raw'' and ``Save link as'') and save them at the root of your project.

\section{Quickstart}

You can create a diagram either with |\zx[options]{matrix}| or with:
\begin{verse}
  |\begin{ZX}[options]|\\
    |  matrix|\\
  |\end{ZX}|
\end{verse}
The matrix is composed of columns separated by |&| and rows separated by |\\|. This matrix is basically a \tikzname{} matrix of nodes (even better, a |tikz-cd| matrix, so you can use all the machinary of |tikz-cd|), so cells can be created using \verb#|tikz style| content#. However, the users does not usually need to use this syntax since many nodes like |\zxZ{spider phase}| have been created for them (including |\zxN{}| which is an empty node):

\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxZ{} & \zxZ{\alpha} & \zxZ-{\alpha} & \zxZ{\alpha+\beta} & \zxFracZ{\pi}{2} & \zxFracZ-{\pi}{2}\\
  \zxX{} & \zxX{\alpha} & \zxX-{\alpha} & \zxX{\alpha+\beta} & \zxFracX{\pi}{2} & \zxFracX-{\pi}{2}\\
  \zxN{} & \zxH{}
\end{ZX}
\end{codeexample}

Note that if a node has no argument like |\zxN|, you should still end it like |\zxN{}| to make sure you code will be backward compatible and will behave correctly.

To link the nodes, you should use |\arrow[options]| (|\ar[options]| for short) at the end of a cell (you can put many arrows). The options can contain a direction, made of a string of |r| (for ``right''), |l| (for ``left''), |d| (for `down''), |u| (for ``up'') letters. That way, |\ar[rrd]| would be an arrow going right, right, and down:
\begin{codeexample}[]
\begin{ZX}
  \zxZ{} \ar[rrd] & \zxX{}\\
                  &        & \zxX-{\alpha}
\end{ZX}
\end{codeexample}
See how the alignment of your matrix helps reading it: in emacs |M-x align| is your friend. You may also encounter some shortcuts, like |\rar| instead of |\ar[r]|. Since straight lines are boring, we created many styles that you can just add in the options. For instance, a measured Bell-pair can be created using the |C| style (note also how the |*| argument forces the node to be tighter):
\begin{codeexample}[]
\begin{ZX}
  \zxZ*{a \pi} \ar[d,C]\\
  \zxZ*{b \pi}
\end{ZX}
\end{codeexample}
The name of the style usually tries to graphically represent the shape of a node (here it looks like a |C|). We also introduce many other styles, like |N| for wires that arrive and leave at wide angle (yeah, the |N| is the best letter I could find to fit that shape):
\begin{codeexample}[]
\begin{ZX}
  \zxN{}                           & \zxZ{\beta}\\
  \zxZ{\alpha} \ar[ru,N] \ar[rd,N] &\\
                                   & \zxZ{\gamma}
\end{ZX}
\end{codeexample}
Or |s| for wires that arrive and leave at sharp angles (the |\zxN{}| is used because it seems that the first cell of a matrix can't be empty):
\begin{codeexample}[]
\begin{ZX}
  \zxN{}                           & \zxZ{\beta}\\
  \zxZ{\alpha} \ar[ru,s] \ar[rd,s] &\\
                                   & \zxZ{\gamma}
\end{ZX}
\end{codeexample}
You have then different variations of a style depending on the shape and/or direction of it. For instance, if we want the arrival of the |N| wire to be flat, use |N-|:
\begin{codeexample}[]
\begin{ZX}
  \zxZ{\alpha} \ar[rd,N-] \\
                         & \zxZ{\beta}
\end{ZX}
\end{codeexample}
Similarly |o'| is a style for wires that have the shape of the top part of the circle, and comes with variations depending on the part of the circle that must be kept:
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxZ{\alpha} \ar[r,o',green] \ar[r,o.,red] \ar[d,o-,blue] \ar[d,-o,purple] & \zxZ{\beta}\\
  \zxZ{\beta}
\end{ZX}
\end{codeexample}
Note that the position of the embellishments (|'|, |-|, |.|\dots{}) tries to graphically represent the shape of the node. That way |-o| means ``take the left part (position of |-|) or the circle |o|''. Applied to |C|, this gives:
\begin{codeexample}[]
\begin{ZX}
  \zxX{} \ar[d,C] \ar[r,C']  & \zxZ{} \ar[d,C-]\\
  \zxZ{} \ar[r,C.]           & \zxX{}
\end{ZX}
\end{codeexample}

You also have styles which automatically add another node in between, for instance |H| adds a Hadamard node in the middle of the node:
\begin{codeexample}[]
\begin{ZX}
  \zxZ{\alpha} \ar[r,o',H] \ar[r,o.,H] &[\zxHCol] \zxZ{\beta}
\end{ZX}
\end{codeexample}
Note that we used also |&[\zxHCol]| instead of |&| (on the first line). This is useful to add an extra space between the columns to have a nicer look. The same apply for rows (see the |*Row| instead of |*Col|):
\begin{codeexample}[]
\begin{ZX}
  \zxZ{\alpha} \ar[d,-o,Z] \ar[d,o-,X] \\[\zxSRow]
  \zxX{\beta}
\end{ZX}
\end{codeexample}
The reason for this is that it is hard to always get exactly the good spacing by default (for instance here \tikzname{} has no idea that a |H| node will be inserted when it starts to build the diagram), and sometimes the spacing needs some adjustments. However, while you could manually tweak this space using something like |&[1mm]| (it adds |1mm| to the column space), it is better to use some pre-configured spaced that can be (re)-configured document-wise to keep a uniform spacing. You could define your own spacing, but we already provide a list for the most important spacings. They all start with |zx|, then you find the type of space: |H| for Hadamard, |S| for spiders, |W| when you connect only |\zxNone| nodes (otherwise the diagram will be too shrinked), |w| when one side of the row contains only |\zxNone|\dots{} and then you find |Col| (for columns spacing) or |Row| (for rows spacing). For instance we can use the |\zxNone| style (|\zxN| for short) style and the above spacing to obtain this:
\begin{codeexample}[]
\begin{ZX}
  \zxN{} \rar &[\zxwCol] \zxH{} \rar &[\zxwCol] \zxN{}
\end{ZX}
\end{codeexample}
\noindent or that:
\begin{codeexample}[]
\begin{ZX}
  \zxN{} \ar[d,C] \ar[dr,s] &[\zxWCol] \zxN{} \\[\zxWRow]
  \zxN{} \ar[ru,s]          &          \zxN{} \\
\end{ZX}
\end{codeexample}


When writing equations, you may also want to change the baseline to align properly your diagrams on a given line like that:
\begin{codeexample}[]
  $\zx[math baseline=myZ]{
    \zxX{}\\
    \zxZ[a=myZ]{}
  }
  = \zx{\zxX{} & \zxZ{}}$
\end{codeexample}

We also provide easy methods like |phase in label right| to change the labelling of a note (per-node, per-picture or document wise) to move the phase in a label automatically:
\begin{codeexample}[]
  \begin{ZX}[phase in label right]
    \zxZ{\alpha} \arrow[d] \\
    \zxFracX-{\pi}{4}
  \end{ZX}
\end{codeexample}

Now you should know enough to start your first diagrams. The rest of the documentation will go through all the styles, customizations and features, including the one needed to obtain:
\begin{codeexample}[width=3cm]
\begin{ZX}
  \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
      & \zxX{\beta} \zxLoopAboveDots{} \rightManyDots{m}
\end{ZX}
\end{codeexample}
\noindent You will also see some tricks (notably based on alias) to create clear bigger diagrams, like this debug mode which turns
{
\begin{ZX}[zx row sep=1pt,
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,)]
  % Column 4
  \ar[from=mypi2,to=toprightpi,(']
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[from=Xdown,to=out3,<.]
\end{ZX} into %
{%
  \def\zxDebugMode{}%%%%
  \begin{ZX}[zx row sep=1pt,
    execute at begin picture={%
      %%% Definition of long items (the goal is to have a small and readable matrix
      % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
      \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
      \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
    }
    ]
    %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
    & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
    \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
    &              &                         &            & \zxN[a=out2]{} \\
    \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
    %%% Arrows
    % Column 1
    \ar[from=in1,to=X1,s]
    \ar[from=in2,to=Zpi4,.>]
    % Column 2
    \ar[from=X1,to=xmiddle,N']
    \ar[from=X1,to=toprightpi,H]
    \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
    \ar[from=Zpi4,to=Xdown]
    % Column 3
    \ar[from=xmiddle,to=Xdown,C-]
    \ar[from=xmiddle,to=mypi2,)]
    % Column 4
    \ar[from=mypi2,to=toprightpi,(']
    \ar[from=mypi2,to=out1,<']
    \ar[from=mypi2,to=out2,<.]
    \ar[from=Xdown,to=out3,<.]
  \end{ZX}
} \ (of course it only helps during the construction).\\

You will also see how you can customize the styles, and how you can easily extand this library to get any custom diagram:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
{ % \usetikzlibrary{shadows}
  \tikzset{
    my bloc/.style={
      anchor=center,
      inner sep=2pt,
      inner xsep=.7em,
      minimum height=3em,
      draw,
      thick,
      fill=blue!10!white,
      double copy shadow={opacity=.5},tape,
    }
  }
  \zx{|[my bloc]| f \rar &[1mm] |[my bloc]| g \rar &[1mm] \zxZ{\alpha} \rar & \zxNone{}}
}
\end{codeexample}
}

If you have some questions, suggestions, or bugs, please report them on \texttt{\url{https://github.com/leo-colisson/zx-calculus/issues}}.

\textbf{Tips}: if you are unsure of the definition of a style in an example, just click on it, a link will point to its definition. Also, if your pdf viewer does not copy/paste these examples correctly, you can copy them from the source code of this documentation available \mylink{https://github.com/leo-colisson/zx-calculus/blob/main/doc/zx-calculus.tex}{here} (to find the example, just use the ``search'' function of your web browser).

\section{Usage}

\subsection{Add a diagram}
\begin{pgfmanualentry}
  \extractcommand\zx\opt{\oarg{options}}\marg{your diagram}\@@
  \extractenvironement{ZX}\opt{\oarg{options}}\@@
  \pgfmanualbody
  You can create a new ZX-diagram either with a command (quicker for inline diagrams) or with an environment. The \meta{options} can be used to locally change the style of the diagram, using the same options as the |{tikz-cd}| environment (from the \mylink{https://www.ctan.org/pkg/tikz-cd}{\texttt{tikz-cd} package}). The \meta{your diagram} argument, or the content of |{ZX}| environment is a \tikzname{} matrix of nodes, exactly like in the |tikz-cd| package: columns are separated using |&|, columns using |\\|, and nodes are created using \verb#|[tikz style]| node content# or with shortcut commands presented later in this document (recommended). Content is typeset in math mode by default, and diagrams can be included in any equation. Wires can be added like in |tikz-cd| (see more below) using |\arrow| or |\ar|: we provide later recommended styles to quickly create different kinds of wires which can change with the configured style.
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
% Do not indent not to put space in final code
\begin{codeexample}[]
Spider \zx{\zxZ{\alpha}}, equation $\zx{\zxZ{}} = \zx{\zxX{}}$ %
and custom diagram: %
\begin{ZX}[red]
  \zxZ{\beta} \arrow[r]                           & \zxZ{\alpha} \\
  |[fill=pink,draw]| \gamma \arrow[ru,bend right]
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}

\subsection{Nodes}

The following commands are useful to create different kinds of nodes. Always add empty arguments like |\example{}| if none are already present, otherwise if you type |\example| we don't guarantee backward compatibility.

\begin{command}{\zxEmptyDiagram{}}
  Create an empty diagram.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxEmptyDiagram{}
\end{ZX}
\end{codeexample}
\end{command}


\begin{pgfmanualentry}
  \extractcommand\zxNone\opt{+}\opt{-}\marg{text}\@@
  \extractcommand\zxN\opt{+}\opt{-}\marg{text}\@@
  \pgfmanualbody
  Adds an empty node with |\zxNone{}| (alias |\zxN{}|). The \verb#-|+# decorations are used to add a bit of horizontal (\verb#\zxNone-{}#), vertical (\verb#\zxNone|{}#) and both (\verb#\zxNone+{}#) spacing (I don't know how to add \verb#|# in the documentation of the function).

  |\zxNone| is just a coordinate (when possible this node should be preferred over the other versions), but |\zxNone-{}| and \verb#\zxNone|{}# are actually nodes with |inner sep=0| along one direction. For that reason, they still have a tiny height or width (impossible to remove as far as I know). If you don't want to get holes when connecting multiple wires to them, it is therefore necessary to use the |wire centered| style (alias |wc|) (if you are using the |IO| mode, see also the |between none| style).

  Moreover, you should also add column and row spacing |&[\zxWCol]| and |\\[\zxWRow]| to avoid too shrinked diagrams when only wires are involved.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxNone{} \ar[C,d] \ar[rd,s] &[\zxWCol] \zxNone{}\\[\zxWRow]
  \zxNone{}          \ar[ru,s] &          \zxNone{}
\end{ZX}
\end{codeexample}
Use |&[\zxwCol]| (on the first line) and/or |\\[\zxwRow]| when a single None node is connected to the wire to add appropriate spacing (this spacing can of course be redefined to your preferences):
\begin{codeexample}[]
Compare \begin{ZX}
  \zxN{} \rar & \zxZ{} \rar & \zxN{}
\end{ZX} with \begin{ZX}
  \zxN{} \rar &[\zxwCol] \zxZ{} \rar &[\zxwCol] \zxN{}
\end{ZX}
\end{codeexample}
Note also that when the top left cell is empty, you can get an error at the compilation (no idea why) |Single ampersand used with wrong catcode|. To prevent that, you can add a none node at this position:
\begin{codeexample}[]
\begin{ZX}
  \zxN{}         &[\zxwCol] \zxN{} \ar[d]\\[\zxwRow]
  \zxNone{} \rar & \zxZ{}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}
You may also get this error when |&| has already a different meaning, for instance in |align|, in that case you may change the |&| character into |\&| using |[ampersand replacement=\&]|:
\begin{codeexample}[vbox]
\begin{align}
  \begin{ZX}[ampersand replacement=\&]
    \zxN{} \rar \&[\zxwCol] \zxN{}
  \end{ZX}
  &= \begin{ZX}[ampersand replacement=\&]
    \zxN{} \rar \&[\zxwCol] \zxZ{} \rar \&[\zxwCol] \zxN{}
  \end{ZX}\\
  &= \begin{ZX}[ampersand replacement=\&]
    \zxN{} \rar \&[\zxwCol] \zxX{} \rar \&[\zxwCol] \zxN{}
  \end{ZX}
\end{align}
\end{codeexample}

\begin{command}{\zxNoneDouble\opt{+-}\marg{text}}
  Like |\zxNone|, but the spacing for \verb#+-|# is large enough to fake two lines in only one. Not extremely useful (or one needs to play with |start anchor=south,end anchor=north|).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxNoneDouble|{} \ar[r,s,start anchor=north,end anchor=south] \ar[r,s,start anchor=south,end anchor=north] &[\zxWCol] \zxNoneDouble|{}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxFracZ\opt{-}\marg{numerator}\opt{\oarg{numerator with parens}\oarg{denominator with parens}}\marg{denominator}}
  Adds a Z node with a fraction, use the minus decorator to add a small minus in front (the default minus is very big).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxFracZ{\pi}{2} & \zxFracZ-{\pi}{2}
\end{ZX}
\end{codeexample}
The optional arguments are useful when the numerator or the denominator need parens when they are written inline (in that case optional arguments must be specified): it will prove useful when using a style that writes the fraction inline, for instance the default style for labels:
\begin{codeexample}[]
Compare
\begin{ZX}
  \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
\end{ZX} with %
\begin{ZX}[phase in label right]
  \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxFracX\opt{-}\marg{numerator}\marg{denominator}}
  Adds an X node with a fraction.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxFracX{\pi}{2} & \zxFracX-{\pi}{2}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxZ\opt{\oarg{other styles}*-}\marg{text}}
  Adds a Z node. \meta{other styles} are optional \tikzname{} arguments (the same as the one provided to |tikz-cd|) They should be use with care, and if possible moved to the style directly to keep a consistent look across the paper.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{} & \zxZ{\alpha} & \zxZ{\alpha + \beta} & \zxZ[text=red]{(a \oplus b)\pi}
\end{ZX}
\end{codeexample}
The optional |-| optional argument is to add a minus sign (customizable, see |\zxMinusInShort|) in front of a very short expression and try to keep a circular shape. This is recommended notably for single letter expressions.
\begin{codeexample}[width=3cm]
  Compare \zx{\zxZ{-\alpha}} with \zx{\zxZ-{\alpha}}. Labels:
  \zx[pila]{\zxZ{-\alpha}} vs \zx[pila]{\zxZ-{\alpha}}.
\end{codeexample}
The |*| optional argument is to force a condensed style, no matter what is the text inside. This can be practical \emph{sometimes}:
\begin{codeexample}[width=3cm]
  Compare \zx{\zxN{} \rar &[\zxwCol] \zxZ{a\pi}} with \zx{\zxN{} \rar &[\zxwCol] \zxZ*{a\pi}}.
\end{codeexample}
\noindent but you should use it as rarely as possible (otherwise, change the style directly). See that it does not always give nice results:
\begin{codeexample}[width=3cm]
  Compare \zx{\zxZ{-\alpha} \rar & \zxZ{\alpha+\beta}}
  with \zx{\zxZ*{-\alpha} \rar & \zxZ*{\alpha+\beta}}.
  Labels:
  \zx[pila]{\zxZ{-\alpha} \rar & \zxZ{\alpha+\beta}}
  vs \zx[pila]{\zxZ*{-\alpha} \rar & \zxZ*{\alpha+\beta}}.
\end{codeexample}
\end{command}


\begin{command}{\zxX\opt{\oarg{other styles}*-}\marg{text}}
  Adds an X node, like for the Z node.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{} & \zxX{\alpha} & \zxX-{\alpha} & \zxX{\alpha + \beta}
  & \zxX[text=green]{(a \oplus b)\pi}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxH\opt{\oarg{other styles}}}
  Adds an Hadamard node. See also |H| wire style.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxNone{} \rar & \zxH{} \rar & \zxNone{}
\end{ZX}
\end{codeexample}
\end{command}



\begin{command}{\leftManyDots\opt{\oarg{text scale}\oarg{dots scale}}\marg{text}}
  Shortcut to add a dots and a text next to it. It automatically adds the new column, see more examples below. Internally, it uses |3 dots| to place the dots, and can be reproduced using the other nodes around. Note that this node automatically adds a new cell, so you should \emph{not} use |&|.
\begin{codeexample}[]
\begin{ZX}
  \leftManyDots{n} \zxX{\alpha}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\leftManyDots\opt{\oarg{text scale}\oarg{dots scale}}\marg{text}}
  Shortcut to add a dots and a text next to it. It automatically adds the new column, see more examples below.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \rightManyDots{m}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\middleManyDots{}}
  Shortcut to add a dots and a text next to it. It automatically adds the new column, see more examples below.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \middleManyDots{} & \zxX{\beta}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxLoop\opt{\oarg{direction angle}\oarg{opening angle}\oarg{other styles}}}
  Adds a loop in \meta{direction angle} (defaults to $90$), with opening angle \meta{opening angle} (defaults to $20$).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \zxLoop{} & \zxX{} \zxLoop[45]{} & \zxX{} \zxLoop[0][30][red]{}
\end{ZX}
\end{codeexample}
\end{command}

\begin{command}{\zxLoopAboveDots\opt{\oarg{opening angle}\oarg{other styles}}}
  Adds a loop above the node with some dots.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \zxLoopAboveDots{}
\end{ZX}
\end{codeexample}
\end{command}

\noindent The previous commands can be useful to create this figure:
\begin{codeexample}[width=0pt]% Forces code/example on two lines.
\begin{ZX}
  \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
      & \zxX{\beta} \zxLoopAboveDots{} \rightManyDots{m}
\end{ZX}
\end{codeexample}

\subsection{Phase in label style}

We also provide styles to place the phase on a label next to an empty node (not yet very well tested):

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles rounded style/phase in content\@nil%
  \extractkey/zx/styles rounded style/phase in label=style (default {})\@nil%
  \extractkey/zx/styles rounded style/pil=style (default {})\@nil%
  \extractkey/zx/styles rounded style/phase in label above=style (default {})\@nil%
  \extractkey/zx/styles rounded style/pila=style (default {})\@nil%
  \extractkey/zx/styles rounded style/phase in label below=style (default {})\@nil%
  \extractkey/zx/styles rounded style/pilb=style (default {})\@nil%
  \extractkey/zx/styles rounded style/phase in label right=style (default {})\@nil%
  \extractkey/zx/styles rounded style/pilr=style (default {})\@nil%
  \extractkey/zx/styles rounded style/phase in label left=style (default {})\@nil%
  \extractkey/zx/styles rounded style/pill=style (default {})\@nil%
  \makeatother
  \pgfmanualbody
  The above styles are useful to place a spider phase in a label outside the node. They can either be put on the style of a node to modify a single node at a time:
\begin{codeexample}[]
  \zx{\zxX[phase in label]{\alpha} \rar & \zxX{\alpha}}
\end{codeexample}
\noindent It can also be configured on a per-figure basis:
\begin{codeexample}[]
\zx[phase in label right]{
  \zxZ{\alpha} \dar \\
  \zxX{\alpha} \dar \\
  \zxZ{}}
\end{codeexample}
\noindent or globally:
\begin{codeexample}[]
{
  \tikzset{
    /zx/user post preparation labels/.style={
      phase in label={label position=-45, text=purple,fill=none}
    }
  }
  \zx{
    \zxFracX-{\pi}{2}
  }
}
\end{codeexample}
Note that we must use |user post preparation labels| and not |/zx/user overlay nodes| because this will be run after all the machinery for labels has been setup.

  While |phase in content| forces the content of the node to be inside the node instead of inside a label (which is the default behavior), all other styles are special cases of |phase in label|. The \meta{style} parameter can be any style made for a tikz label:
\begin{codeexample}[width=3cm]
  \zx{
    \zxX[phase in label={label position=45, text=purple}]{\alpha}
  }
\end{codeexample}

For ease of use, the special cases of label position |above|, |below|, |right| and |left| have their respective shortcut style. The |pil*| versions are shortcuts of the longer style written above. For instance, |pilb| stands for |phase in label below|. Note also that by default labels will take some space, but it's possible to make them overlay without taking space using the |overlay| label style\dots{} however do it at your own risks as it can overlay the content around (also the text before and after):
\begin{codeexample}[width=0pt]
  \zx{
    \zxZ[pilb]{\alpha+\beta} \rar & \zxX[pilb]{\gamma} \rar & \zxZ[pilb=overlay]{\gamma+\eta}
  }
\end{codeexample}
The above also works for fractions:
\begin{codeexample}[]
\zx{\zxFracX[pilr]-{\pi}{2}}
\end{codeexample}
For fractions, you can configure how you want the label text to be displayed, either in a single line (default) or on two lines, like in nodes. The function |\zxConvertToFracInLabel| is in charge of that conversion, and can be changed to your needs to change this option document-wise. To use the same notation in both content and labels, you can do:
\begin{codeexample}[width=0pt]
  Compare
  \begin{ZX}[phase in label right]
    \zxFracZ{\pi}{2} \dar \\
    \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
  \end{ZX} with
{\RenewExpandableDocumentCommand{\zxConvertToFracInLabel}{mmmmm}{
    \zxConvertToFracInContent{#1}{#2}{#3}{#4}{#5}%
  }
  \begin{ZX}[phase in label right]
    \zxFracZ{\pi}{2} \dar \\
    \zxFracZ{a+b}[(a+b)][(c+d)]{c+d}
  \end{ZX} (exact same code!)
}
\end{codeexample}
Note that in |\zxFracZ{a+b}[(a+b)][(c+d)]{c+d}| the optional arguments are useful to put parens appropriately when the fraction is written inline.
\end{pgfmanualentry}

\begin{command}{\zxDebugMode{}}
  If this macro is defined, debug mode is active. See below how it can be useful.
\end{command}
\begin{stylekey}{/tikz/every node/a=alias}
  Shortcut to add an |alias| to a wire, and in debug mode it also displays the alias of the nodes next to it (very practical to quickly add wires as we will see later). To enable debug mode, just type |\def\zxDebugMode{}| before your drawing, potentially in a group like |{\def\zxDebugMode{} your diagram...}| if you want to apply it to a single diagram.

  This will be very practical later when using names instead of directions to connect wires (this can improve readability and maintainability). This is added automatically in |/tikz/every node| style. Note that debug mode is effective only for |a| and not |alias|.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX[a=A]{} & \zxZ[a=B]{\beta}
    \ar[from=A,to=B]
  \end{ZX}
  {\def\zxDebugMode{} %% Enable debug mode for next diagram%
    \begin{ZX}
      \zxX[a=A]{} & \zxZ[a=B]{\beta}
      \ar[from=A,to=B]
    \end{ZX}
  }
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/zx/defaultEnv/math baseline=node alias}
  You can easily change the default baseline which defaults to:
  \begin{verse}
    |baseline={([yshift=-axis_height]current bounding box.center)}|
  \end{verse}
  (|axis_height| is the distance to use to center equations on the ``mathematical axis'') by using this in the \meta{options} field of |\zx[options]{...}|. However, this can be a bit long to write, so |math baseline=yourAlias| is a shorcut to |baseline={([yshift=-axis_height]yourAlias)}|:
\begin{codeexample}[width=0pt]
  Compare $\begin{ZX}
    \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
    & \zxX{\beta} \zxLoopAboveDots{} \rightManyDots{m}
  \end{ZX}
  = {\def\zxDefaultSoftAngleS{20} % useful to make the angle in \leftManyDots{} nicer.
    \begin{ZX}
      \leftManyDots{n} \zxX{\alpha+\beta} \rightManyDots{m}
    \end{ZX}}$ with $\begin{ZX}[math baseline=wantedBaseline]
    \leftManyDots{n} \zxX{\alpha} \zxLoopAboveDots{} \middleManyDots{} \ar[r,o'={a=75}]
    %% See here --v the node chosen as the baseline
    & \zxX[a=wantedBaseline]{\beta} \zxLoopAboveDots{} \rightManyDots{m}
  \end{ZX}
  = {\def\zxDefaultSoftAngleS{20} % useful to make the angle in \leftManyDots{} nicer.
    \begin{ZX}
      \leftManyDots{n} \zxX{\alpha+\beta} \rightManyDots{m}
    \end{ZX}}$
\end{codeexample}
Also, if you find your diagram a bit ``too high'', check that you did not forget to remove a trailing |\\| at the end of the last line:
\begin{codeexample}[width=3cm]
  Compare $\begin{ZX}
    \zxZ{} \rar[o'] \rar[o.]      & \zxX{}\\
    \zxZ{} \rar[o'] \rar[o.] \rar & \zxX{}\\ %% <--- remove last |\\|
  \end{ZX} = \zx{\zxEmptyDiagram}$ with $\begin{ZX}
    \zxZ{} \rar[o'] \rar[o.]      & \zxX{}\\
    \zxZ{} \rar[o'] \rar[o.] \rar & \zxX{}
  \end{ZX}  = \zx{\zxEmptyDiagram}$
\end{codeexample}
\end{stylekey}

\subsection{Wires}

\subsubsection{Creating wires and debug mode}

\begin{pgfmanualentry}
  \extractcommand\arrow\opt{\oarg{options}}\@@
  \extractcommand\ar\opt{\oarg{options}}\@@
  \pgfmanualbody
  These synonym commands (actually coming from |tikz-cd|) are used to draw wires between nodes. We refer to |tikz-cd| for an in-depth documentation, but what is important for our purpose is that the direction of the wires can be specified in the \meta{options} using a string of letters |r| (right), |l| (left), |u| (up), |d| (down). It's also possible to specify a node alias as a source or destination as shown below.
\begin{codeexample}[]
\zx{\zxZ{} \ar[r] & \zxX{}} = \zx{\zxX{} \arrow[rd] \\ & \zxZ{}}
\end{codeexample}
  \meta{options} can also be used to add any additional style, either custom ones, or the ones defined in this library (this is recommended since it can be easily changed document-wise by simply changing the style). Multiple wires can be added in the same cell. Other shortcuts provided in |tikz-cd| like |\rar|\dots{} can be used.
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
\begin{ZX}
  \zxZ{\alpha} \arrow[d, C] % C = Bell-like wire
               \ar[r,H,o']  % o' = top part of circle
               % H adds Hadamard, combine with \zxHCol
               \ar[r,H,o.] &[\zxHCol] \zxZ{\gamma}\\
  \zxZ{\beta}  \rar        & \zxX{} \ar[ld,red,"\circ" {marking,blue}] \ar[rd,s] \\
  \zxFracX-{\pi}{4}        & &\zxZ{}
\end{ZX}
\end{codeexample}
}
\end{pgfmanualentry}

As explained in |tikz-cd|, there are further shortened forms:
\begin{pgfmanualentry}
  \extractcommand\rar\opt{\oarg{options}}\@@
  \extractcommand\lar\opt{\oarg{options}}\@@
  \extractcommand\dar\opt{\oarg{options}}\@@
  \extractcommand\uar\opt{\oarg{options}}\@@
  \extractcommand\drar\opt{\oarg{options}}\@@
  \extractcommand\urar\opt{\oarg{options}}\@@
  \extractcommand\dlar\opt{\oarg{options}}\@@
  \extractcommand\ular\opt{\oarg{options}}\@@
  \pgfmanualbody
\end{pgfmanualentry}
The first one is equivalent to
\begin{verse}
  |\arrow|{\oarg{options}}|{r}|
\end{verse}
and the other ones work analogously.

Note that sometimes, it may be practical to properly organize big diagrams to increase readability. To that end, one surely wants to have a small and well indented matrix (emacs |M-x align-current| or |M-x align| (for selected lines) commands are very practical to indent matrices automatically). Unfortunately, adding wires inside the matrix can make the line really long and hard to read. Similarly, some nodes involving fractions or long expressions can also be quite long. It is however easy to increase readability (and maintainability) by moving the wires at the very end of the diagram, using |a| (like |alias|, but with a debug mode) to connect nodes and |\def| to create shortcuts. Putting inside a macro with |\def| long node definitions can also be useful to keep small items in the matrix:
\begin{codeexample}[width=0pt]
\begin{ZX}[zx row sep=1pt,
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align-current" is practical to automatically format it.
  %%% a is for 'alias'... but also provides a debug mode, see below.
                &              &                   &                 & \zxZ[a=toprightpi]{\pi} \\
  \zxN[a=in1]{} & \zxX[a=X1]{} &                   &                 &  & \zxN[a=out1]{}       \\
                &              & \zxZ[a=xmiddle]{} & \mypitwo{}      &  & \zxN[a=out2]{}       \\
  \zxN[a=in2]{} & \Zpifour{}   &                   & \zxX[a=Xdown]{} &  & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1]
  \ar[from=in2,to=Zpi4]
  % Column 2
  \ar[from=X1,to=xmiddle,(.]
  \ar[from=X1,to=toprightpi,<',H]
  \ar[from=Zpi4,to=xmiddle,(']
  \ar[from=Zpi4,to=Xdown,o.]
  % Column 3
  \ar[from=xmiddle,to=Xdown,s.]
  \ar[from=xmiddle,to=mypi2]
  % Column 4
  \ar[from=mypi2,to=toprightpi,(']
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2]
  \ar[from=Xdown,to=out3]
\end{ZX}
\end{codeexample}
In that setting, it is often useful to enable the debug mode via |\def\zxDebugMode{}| as explained above to quickly visualize the alias given to each node (note that debug mode works with |a=| but not with |alias=|). For instance, it was easy to rewrite the above diagram by moving nodes in the matrix and arrows after checking their name on the produced pdf (NB: you can increase |column sep| and |row sep| temporarily to make the debug information more visible):
\begin{codeexample}[width=0pt]
{
  \def\zxDebugMode{}%%%%
  \begin{ZX}[zx row sep=1pt,
    execute at begin picture={%
      %%% Definition of long items (the goal is to have a small and readable matrix
      % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
      \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
      \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
    }
    ]
    %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
    & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
    \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
    &              &                         &            & \zxN[a=out2]{} \\
    \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
    %%% Arrows
    % Column 1
    \ar[from=in1,to=X1,s]
    \ar[from=in2,to=Zpi4,.>]
    % Column 2
    \ar[from=X1,to=xmiddle,N']
    \ar[from=X1,to=toprightpi,H]
    \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
    \ar[from=Zpi4,to=Xdown]
    % Column 3
    \ar[from=xmiddle,to=Xdown,C-]
    \ar[from=xmiddle,to=mypi2,)]
    % Column 4
    \ar[from=mypi2,to=toprightpi,(']
    \ar[from=mypi2,to=out1,<']
    \ar[from=mypi2,to=out2,<.]
    \ar[from=Xdown,to=out3,<.]
  \end{ZX}
}
\end{codeexample}

\subsubsection{Wire styles (new generation)}

We give now a list of wire styles provided in this library (|/zx/wires definition/| is an automatically loaded style). We recommend using them instead of manual styling to ensure they are the same document-wise, but they can of course be customized to your need. Note that the name of the styles are supposed (ahah, I do my best with what ASCII provides) to graphically represent the action of the style, and some characters are added to precise the shape: typically |'| means top, |.| bottom, |X-| is right to X (or should arrive with angle 0), |-X| is left to X (or should leave with angle zero). These shapes are usually designed to work when the starting node is left most (or above of both nodes have the same column). But they may work both way for some of them.

Note that the first version of that library (which appeared one week before this new version\dots{} hopefully backward compatibility won't be too much of a problem) was using |in=| and |out=| to create these styles. However, it turns out to be not very reliable since the shape of the wire was changing (sometimes importantly) depending on the position of the nodes. This new version should be more reliable, but the older styles are still available by using |IO, nameOfWirestyle| (read more in \cref{subsub:IOwires}).

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/C=radius ratio (default 1)\@nil%
  \extractkey/zx/wires definition/C.=radius ratio (default 1)\@nil%
  \extractkey/zx/wires definition/C'=radius ratio (default 1)\@nil%
  \extractkey/zx/wires definition/C-=radius ratio (default 1)\@nil%
  \makeatother
  \pgfmanualbody
  Bell-like wires with an arrival at ``right angle'', |C| represents the shape of the wire, while |.| (bottom), |'| (top) and |-| (side) represent (visually) its position. Combine with |wire centered| (|wc|) to avoid holes when connecting multiple wires (not required with |\zxNone{}|, alias |\zxN{}|).
\begin{codeexample}[]
  A Bell pair \zx{\zxNone{} \ar[d,C] \\[\zxWRow]
                \zxNone{}}
  , a swapped Bell pair
  \begin{ZX}
    \zxN{} \ar[d,C] \ar[rd,s] &[\zxWCol] \zxN{} \\[\zxWRow]
    \zxN{}          \ar[ru,s] &          \zxN{}
  \end{ZX}
  and a funny graph
  \begin{ZX}
    \zxX{} \ar[d,C] \ar[r,C']  & \zxZ{} \ar[d,C-]\\
    \zxZ{} \ar[r,C.]           & \zxX{}
  \end{ZX}.
\end{codeexample}
Note that this style is actually connecting the nodes using a perfect circle (it is \emph{not} based on |curve to|), and therefore should \emph{not} be used together with |in|, |out|, |looseness|\dots{} (this is the case also for most other styles except the ones in |IO|). It has the advantage of connecting nicely nodes which are not aligned or with different shapes:
\begin{codeexample}[]
  \begin{ZX}
    \zxX{\alpha} \ar[dr,C]\\
    & \zxNone{}
  \end{ZX}
\end{codeexample}
The \meta{radius ratio} parameter can be used to turn the circle into an ellipse using this ratio between both axis:
\begin{codeexample}[]
  \begin{ZX}
    \zxX{\alpha}
      \ar[dr,C=0.5,red]
      \ar[dr,C,green]
      \ar[dr,C=2,blue]
      \ar[dr,C=3,purple]\\
                        & \zxNone{}
  \end{ZX}
  \begin{ZX}
    \zxX{} \ar[d,C=2] \ar[r,C'=2]  & \zxZ{} \ar[d,C-=2,H]\\
    \zxZ{} \ar[r,C.=2]           & \zxX{}
  \end{ZX}.
\end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/o'=angle (default 40)\@nil%
  \extractkey/zx/wires definition/o.=angle (default 40)\@nil%
  \extractkey/zx/wires definition/o-=angle (default 40)\@nil%
  \extractkey/zx/wires definition/-o=angle (default 40)\@nil%
  \makeatother
  \pgfmanualbody
  Curved wire, similar to |C| but with a soften angle (optionally specified via \meta{angle}, and globally editable with |\zxDefaultLineWidth|). Again, the symbols specify which part of the circle (represented with |o|) must be kept.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[d,-o] \ar[d,o-]\\
    \zxZ{} \ar[r,o'] \ar[r,o.] & \zxX{}
  \end{ZX}.
\end{codeexample}
 Note that these wires can be combined with |H|, |X| or |Z|, in that case one should use appropriate column and row spacing as explained in their documentation:
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[d,-o,H] \ar[d,o-,H]\\[\zxHRow]
    \zxZ{\beta} \rar & \zxZ{} \ar[r,o',X] \ar[r,o.,Z] &[\zxSCol] \zxX{}
  \end{ZX}.
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/(=angle (default 30)\@nil%
  \extractkey/zx/wires definition/)=angle (default 30)\@nil%
  \extractkey/zx/wires definition/('=angle (default 30)\@nil%
  \extractkey/zx/wires definition/('=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  Curved wire, similar to |o| but can be used for diagonal items. The angle is, like in |bend right|, the opening angle from the line which links the two nodes. For the first two commands, the |(| and |)| symbols must be imagined as if the starting point was on top of the parens, and the ending point at the bottom.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[rd,(] \ar[rd,),red]\\
    & \zxZ{}
  \end{ZX}.
\end{codeexample}
Then, |('|=|(| and |(.|=|)|; this notation is, I think, more intuitive when linking nodes from left to right. |('| is used when going to top right and |(.| when going to bottom right.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxN{}                       & \zxX{}\\
  \zxZ{} \ar[ru,('] \ar[rd,(.] & \\
                               & \zxX{}
\end{ZX}
\end{codeexample}
When the nodes are too far appart, the default angle of |30| may produce strange results as it will go above (for |('|) the vertical line. Either choose a shorter angle, or see |<'| instead. Note that for now this node is based on |in| and |out|, but it may change later. So if you want to change looseness, or really rely on the precise specified angle, prefer to use |IO,(| instead (which takes the |IO| version, guaranteed to stay untouched).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/start fake center north\@nil%
  \extractkey/zx/wires definition/start fake center south\@nil%
  \extractkey/zx/wires definition/start fake center east\@nil%
  \extractkey/zx/wires definition/start fake center west\@nil%
  \extractkey/zx/wires definition/start real center\@nil
  \extractkey/zx/wires definition/end fake center north\@nil%
  \extractkey/zx/wires definition/end fake center south\@nil%
  \extractkey/zx/wires definition/end fake center east\@nil%
  \extractkey/zx/wires definition/end fake center west\@nil%
  \extractkey/zx/wires definition/end real center\@nil
  \extractkey/zx/wires definition/left to right\@nil%
  \extractkey/zx/wires definition/right to left\@nil%
  \extractkey/zx/wires definition/up to down\@nil%
  \extractkey/zx/wires definition/down to up\@nil%
  \extractkey/zx/wires definition/force left to right\@nil%
  \extractkey/zx/wires definition/force right to left\@nil%
  \extractkey/zx/wires definition/force up to down\@nil%
  \extractkey/zx/wires definition/force down to up\@nil%
  \extractkey/zx/wires definition/no fake center\@nil%
  \makeatother
  \pgfmanualbody
  Usually each wire should properly use these functions, so the end user should not need that too often (during a first reading, you can skip this paragraph). We added 4 anchors to nodes: |fake center north|, |fake center south|, |fake center east| and |fake center west|. These anchors are used to determine the starting point of the wires depending on the direction of the wire (I tried to use more complex methods to ensure the wires would start on the boundary, but \mylink{https://tex.stackexchange.com/questions/619274}{they all fail}). Because some nodes may not have these anchors, we can't directly set |start anchor=fake center north, on layer=edgelayer| (but the user can do that if they are using only nodes with these anchors) or the code may fail on some nodes. For that reason, we check that these anchors exist while drawing our wires (which, at the best of my knowledge, can only be done while drawing the path). The |start/end fake center *| code is responsible to configure that properly (|start real center| will use the real center), and |left to right| (and similar) just configure both the |start| and |end| point to ensure the node starts at the appropriate anchor. However this won't work for style not defined in this library: in case you are sure that these anchors exists and want to use your own wire styles, you can then set the anchors manually and use |on layer=edgelayer|, or use |force left to right| (and similar) which will automatically do that for the |start| and |end| points.
\begin{codeexample}[]
\begin{ZX}
  \zxX{\alpha+\beta} \ar[r,o',no fake center] & \zxZ{\alpha+\beta}\\
  \zxX{\alpha+\beta} \ar[r,o'] & \zxZ{\alpha+\beta}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/args/-andL/-=x\@nil%
  \extractkey/zx/args/-andL/1-=x\@nil%
  \extractkey/zx/args/-andL/2-=x\@nil%
  \extractkey/zx/args/-andL/L=y\@nil%
  \extractkey/zx/args/-andL/1L=y\@nil%
  \extractkey/zx/args/-andL/2L=y\@nil%
  \extractkey/zx/args/-andL/1 angle and length=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/1al=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/2 angle and length=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/2al=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/angle and length=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/al=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/1 angle=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/1a=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/2 angle=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/1a=\marg{angle}\marg{length}\@nil%
  \extractkey/zx/args/-andL/angle=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/a=\marg{angle}\@nil%
  \extractkey/zx/args/-andL/symmetry-L\@nil%
  \extractkey/zx/args/-andL/symmetry\@nil%
  \extractkey/zx/args/-andL/negate1L\@nil%
  \extractkey/zx/args/-andL/negate2L\@nil%
  \extractkey/zx/args/-andL/negateL\@nil%
  \extractkey/zx/args/-andL/negate1-\@nil%
  \extractkey/zx/args/-andL/negate2-\@nil%
  \extractkey/zx/args/-andL/negate-\@nil%
  \extractkey/zx/args/-andL/oneMinus1-\@nil%
  \extractkey/zx/args/-andL/oneMinus2-\@nil%
  \extractkey/zx/args/-andL/oneMinus1L\@nil%
  \extractkey/zx/args/-andL/oneMinus2L\@nil%
  \makeatother
  \pgfmanualbody
  The next wires can take multiple options. They are all based on the same set of options for now, namely |/zx/args/-andL/|. The |1*| options are used to configure the starting point, the |2*| to configure the ending point, if no number is given both points are updated. |-| and |L| are used to place two anchors of a Bezier curve. They are expressed in relative distance (so they are typically between $0$ and $1$, but can be pushed above $1$ or below $0$ for stronger effects), |-| is typically on the |x| axis and |L| on the |y| axis (the name represents ``graphically'' the direction). They are however not named |x| and |y| because some wires use them slighlty differently, notably |o| which uses |-| for the direction of the arrow and |L| for the direction perpendicular to the arrow (again the shape of |L| represents a perpendicular line). Each wire interprets |-| and |L| to ensure that $0$ should lead to a straight line, and that a correct shape is obtained when |1-| equals |2-|, |1L| equals |2L| (except for non-symmetric shapes of course), and both |-| and |L| are positive.

  The other expressions involving |angle| (or the shortcut |a|) allow you to define |1-|,|1L|\dots{} using a maybe more intuitive ``polar'' notation, i.e.\ an ``angle'' and a relative length (if not specified, like in |1 angle|, the length defaults to $0.6$). Note that the angle is not really an angle (it is an angle only when the nodes are placed at $45$ degrees, or for the |bezier x/y| variations), but a ``squeezed angle'' (when nodes are not at $45$ degrees, the shape is squeezed horizontally or vertically not to change the wire) and similarly for the length. In the above list, the meaning of each expression should be clear from the name: for instance |1angle and length={45}{.8}| will setup a squeezed angle of $45$ and a relative length of $.8$ for the first point, i.e.\ this is equivalent to $1-=.8\cos(45)$ and $1L=.8\sin(45)$, and |angle=45| will change the angle of both points to $45$, with a relative length of $.6$. In the above list, each long expression has below it a shorter version, for intance |a=45| is equivalent to |angle=45|.

  The last expressions (|symmetry-L|, |symmetry|\dots) are used internally to do some math. Of course if you need to do symmetries at some point you can use these keys (|symmetry-L| exchange |-| and |L|, and |symmetry| exchanges |1| and |2|), |negateX| just negates |X| and |oneMinusX| replaces |X| with |1-X|. Each of the following nodes have default values which can be configured as explained in \cref{subsec:wirecustom}.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/s=-andL config (default defaultS)\@nil%
  \extractkey/zx/wires definition/s'=-andL config (default defaultS')\@nil%
  \extractkey/zx/wires definition/s.=-andL config (default defaultS')\@nil%
  \extractkey/zx/wires definition/-s=-andL config (default default-S)\@nil%
  \extractkey/zx/wires definition/-s'=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/-s.=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/s-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/s'-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/s.-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/-S=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/-S'=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/-S.=-andL config (default \{defaultS',default-S\})\@nil%
  \extractkey/zx/wires definition/S-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/S'-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \extractkey/zx/wires definition/S.-=-andL config (default \{defaultS',default-S,symmetry\})\@nil%
  \makeatother
  \pgfmanualbody
  |s| and |S| are used to create a s-like wire, to have nicer diagonal lines between nodes. Other versions are soften versions (the input and output angles are not as sharp. Adding |'| or |.| specifies if the wire is going up-right or down-right, however as of today if it mostly used for backward compatibility since, for instance, |-s'| is the same as |-s| (but some styles may want to do a difference later). The only exception is for |s|/|s'|/|s.|: |s| has a sharper output angle than |s'| and |s.| (which are both equals).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[s,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[s.,rd] \\
                           & \zxZ{\beta}\\
                           & \zxZ{\alpha}\\
    \zxX{\beta} \ar[S,ru] \\
                           & \zxZ{\alpha}\\
    \zxX{\beta} \ar[s',ru] \\
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal. Because for now the wires start inside the node, this is not very visible. For that reason, versions with a capital |S| have an anchor on the side of |-| lying on the surface of the node (|S| has two such anchors since both inputs and outputs arrives horizontally) instead of on the |fake center *| anchor (see explanation on |fake center| anchors above).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[-s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[s.-,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[S,rd] \\
                           & \zxZ{\beta}\\
  \end{ZX}
\end{codeexample}
It is possible to configure it using the options in |-andL config| as explained above (default values are given in \cref{subsec:wirecustom}), where |-| is the (relative) position of the horizontal Bezier anchor and |L| its relative vertical position (to keep a |s|-shape, you should have |-|$>$|L|).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \ar[rd,s.] \\
  & \zxZ{\beta}\\
  % same as s., configure globally using defaultS'\\
  \zxX{\alpha} \ar[rd,s.={-=.8,L=.2}]\\
                 & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,s.={L=.4}] \\
                 & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,s.={L=0.1,-=1}] \\
                 & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,edge above, control points visible,s.={-=2}] \\
                 & \zxZ{\beta}
\end{ZX}
\end{codeexample}
For the non-symmetric versions (involving a vertical arrival), you can configure each point separately using |1-| and |1L| (first point) and |2-| and |2L| (second points). You can also specify the ``squeezed angle'' and ``length'' of each point, for instance using the |1 angle and length={10}{.8}| option (short version is |1al={10}{.8}|) or both at the same time using |al={10}{.6}| (this last command being itself equivalent to |a=10|). As explained later |edge above| and |control points visible| can help you to visualize the control points of the underlying Bezier curve.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxZ{} \ar[dr,s.={al={10}{.8}}]\\ &\zxZ{}\\
    \zxZ{} \ar[edge above,control points visible,dr,s.={a=10}]\\ &\zxZ{}
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/ss=-andL config (default \{defaultS,symmetry-L\})\@nil%
  \extractkey/zx/wires definition/SS=-andL config (default \{defaultS,symmetry-L\})\@nil%
  \extractkey/zx/wires definition/ss.=-andL config (default \{defaultS',symmetry-L\})\@nil%
  \extractkey/zx/wires definition/.ss=-andL config (default \{defaultS',symmetry-L\}30)\@nil%
  \extractkey/zx/wires definition/sIs.=-andL config (default defaultSIS)\@nil%
  \extractkey/zx/wires definition/.sIs=-andL config (default \{defaultS',defaultSIS\})\@nil%
  \extractkey/zx/wires definition/ss.I-=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/I.ss-=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/SIS=-andL config (default \{defaultS',defaultSIS\})\@nil%
  \extractkey/zx/wires definition/.SIS=-andL config (default \{defaultS',defaultSIS\})\@nil%
  \extractkey/zx/wires definition/ISS=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/SS.I=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/I.SS=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \extractkey/zx/wires definition/SSI=-andL config (default \{defaultS',defaultSIS,symmetry\})\@nil%
  \makeatother
  \pgfmanualbody
  |ss| is similar to |s| except that we go from top to bottom instead of from left to right. The position of |.| says if the node is wire is going bottom right (|ss.|) or bottom left (|.ss|).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[ss.,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[.ss,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[.ss={},dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
|I| forces the angle above (if in between the two |s|) or below (if on the same side as |.|) to be vertical.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[sIs.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[ss.I,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[.sIs,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[I.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
The |S| version forces the anchor on the vertical line to be on the boundary.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[SS,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[SIS,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[SSI,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[.sIs,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[I.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
As for |s| it can be configured:
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxX{\alpha} \ar[rd,SIS] \\
                             & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,SIS={1L=.4}] \\
                             & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,SIS={1L=.8}] \\
                             & \zxZ{\beta}\\
  \zxX{\alpha} \ar[rd,SIS={1L=1,2L=1}] \\
                             & \zxZ{\beta}\\
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/N=-andL config (default defaultN)\@nil%
  \extractkey/zx/wires definition/N'=-andL config (default defaultN)\@nil%
  \extractkey/zx/wires definition/N.=-andL config (default defaultN)\@nil%
  \extractkey/zx/wires definition/-N=-andL config (default \{defaultN,defaultN-\})\@nil%
  \extractkey/zx/wires definition/-N'=-andL config (default \{defaultN,defaultN-\})\@nil%
  \extractkey/zx/wires definition/-N.=-andL config (default \{defaultN,defaultN-\})\@nil%
  \extractkey/zx/wires definition/N-=-andL config (default \{defaultN,defaultN-,symmetry\})\@nil%
  \extractkey/zx/wires definition/N'-=-andL config (default \{defaultN,defaultN-,symmetry\})\@nil%
  \extractkey/zx/wires definition/N.-=-andL config (default \{defaultN,defaultN-,symmetry\})\@nil%
  \extractkey/zx/wires definition/Nbase=-andL config (default defaultN)\@nil%
  \makeatother
  \pgfmanualbody
  |N| is used to create a left-to-right wire leaving at wide angle and arriving at wide angle (it's named |N| because it roughly have the shape of a capital |N|). In older versions, |'| and |.| was required to specify if the wire should go up-right or down-right, but it is not useful anymore (we keep it for compatibilty with |IO| styles and in case some styles want to do a distinction later).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[N,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[N,ru]
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[-N,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[N-,ru]
  \end{ZX}
\end{codeexample}
Like other wires, it can be configured using |-| (horizontal relative position of anchor points) and |L| (vertical relative position of anchor points, make sure to have |-|$<$|L| to have a |N|-looking shape), |al={angle}{relative length}|\dots{}
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[N,rd] \\
                               & \zxZ{\beta}\\
    \zxX{\alpha} \ar[N={L=1.2},rd] \\
                               & \zxZ{\beta}
  \end{ZX}
\end{codeexample}
All these styles are based on Nbase (which should not be used directly), including the styles like |<|. If you wish to overwrite later |N|-like commands, but not |<|-like, then change |N|. If you wish to also update |<| commands, use |Nbase|.
\end{pgfmanualentry}



\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/NN=-andL config (default \{defaultN,symmetry-L,defaultNN\})\@nil%
  \extractkey/zx/wires definition/NN.=-andL config (default \{defaultN,symmetry-L,defaultNN\})\@nil%
  \extractkey/zx/wires definition/.NN=-andL config (default \{defaultN,symmetry-L,defaultNN\})\@nil%
  \extractkey/zx/wires definition/NIN=-andL config (default \{defaultN,symmetry-L,defaultNN,defaultNIN\})\@nil%
  \extractkey/zx/wires definition/INN=-andL config (default \{defaultN,symmetry-L,defaultNN,defaultNIN,symmetry\})\@nil%
  \extractkey/zx/wires definition/NNI=-andL config (default \{defaultN,symmetry-L,defaultNN,defaultNIN,symmetry\})\@nil%
  \makeatother
  \pgfmanualbody
  Like |N| but for diagrams read up-to-down or down-to-up. The |.| are maintly used for backward compatibility with |IO| style.
% \begin{codeexample}[width=3cm]
%   \begin{ZX}
%     \zxX{\alpha} \ar[NN,rd] \\
%                                & \zxZ{\beta}\\
%                                & \zxZ{\alpha}\\
%     \zxX{\beta} \ar[NN,ru]
%   \end{ZX}
% \end{codeexample}
% |I| forces the angle on the side of |I| to be vertical.
% \begin{codeexample}[width=3cm]
%   \begin{ZX}
%     \zxX{\alpha} \ar[NIN,rd] \\
%                                & \zxZ{\beta}\\
%                                & \zxZ{\alpha}\\
%     \zxX{\beta} \ar[NNI,ru]
%   \end{ZX}
% \end{codeexample}
% It can be configured like |N| using |-|, |L|\dots{}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/<'=-andL config (default like N-)\@nil%
  \extractkey/zx/wires definition/<.=-andL config (default like N-)\@nil%
  \extractkey/zx/wires definition/'>=-andL config (default like -N)\@nil%
  \extractkey/zx/wires definition/.>=-andL config (default like -N)\@nil%
  %\extractkey/zx/wires definition/^.=-andL config (default 60)\@nil%
  %\extractkey/zx/wires definition/.^=-andL config (default 60)\@nil%
  \extractkey/zx/wires definition/'v=-andL config (default like INN)\@nil%
  \extractkey/zx/wires definition/v'=-andL config (default like NNI)\@nil%
  \makeatother
  \pgfmanualbody
  |<'| and |<.| are similar to |N-|, except that the anchor of the vertical line is put on the boundary (similarly for |*>| and |-N|, |*v*| and |INN|, and |*^*| and |NIN|: |.^| and |^.| were not possible to put in this documentation since the documentation package does not like the |^| character). The position of |'| and |.| does not really matters anymore in new versions, but for backward compatibility with |IO| styles, and maybe forward compatibility (another style may need this information), it's cleaner to put |.| or |'| on the direction of the wire. It also helps the reader of your diagrams to see the shape of the wire.
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{}                         & \zxZ{}\\
  \zxX{} \ar[ru,<'] \ar[rd,<.] \\
  \zxN{}                         & \zxZ{}\\
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{}                         & \zxZ{}\\
  \zxX{} \ar[ru,.>] \ar[rd,'>] \\
  \zxN{}                         & \zxZ{}\\
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{} & \zxFracX{\pi}{2} \ar[dl,.^] \ar[dr,^.] & \\
  \zxZ{} &                                & \zxX{}
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxZ{} &                                & \zxX{}\\
  \zxN{} & \zxX{} \ar[ul,'v] \ar[ur,v'] &
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/3 dots=text (default =)\@nil%
  \extractkey/zx/wires definition/3 vdots=text (default =)\@nil%
  \makeatother
  \pgfmanualbody
  The styles put in the middle of the wire (without drawing the wire) $\dots$ (for |3 dots|) or $\vdots$ (for |3 vdots|). The dots are scaled according to |\zxScaleDots| and the text \meta{text} is written on the left. Use |&[\zxDotsRow]| and |\\[\zxDotsRow]| to properly adapt the spacing of columns and rows.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{\alpha} \ar[r,o'] \ar[r,o.]
               \ar[r,3 dots]
               \ar[d,3 vdots={$n$\,}] &[\zxDotsCol] \zxFracX{\pi}{2}\\[\zxDotsRow]
  \zxZ{\alpha} \rar             & \zxFracX{\pi}{2}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/H=style (default {})\@nil%
  \extractkey/zx/wires definition/Z=style (default {})\@nil%
  \extractkey/zx/wires definition/X=style (default {})\@nil%
  \makeatother
  \pgfmanualbody
  Adds a |H| (Hadamard), |Z| or |X| node (without phase) in the middle of the wire. Width of column or rows should be adapted accordingly using |\zxNameRowcolFlatnot| where |Name| is replaced by |H|, |S| (for ``spiders'', i.e.\ |X| or |Z|), |HS| (for both |H| and |S|) or |W|, |Rowcol| is either |Row| (for changing row sep) or |Col| (for changing column sep) and |Flatnot| is empty or |Flat| (if the wire is supposed to be a straight line as it requires more space). For instance:
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{\alpha} \ar[d] \ar[r,o',H] \ar[r,o.,H] &[\zxHCol] \zxX{\beta}\\
  \zxZ{\alpha}  \ar[d,-o,X] \ar[d,o-,Z]                        \\[\zxHSRow]
  \zxX{\gamma}
\end{ZX}
\end{codeexample}
The \meta{style} parameter can be used to add additional \tikzname{} style to the nodes, notably a position using |\ar[rd,-N.,H={pos=.35}]|. The reason for using that is that the wires start inside the nodes, therefore the ``middle'' of the wire is closer to the node when the other side is on an empty node.
\begin{codeexample}[width=0pt]
\begin{ZX}[zx row sep=0pt]
 \zxN{} \ar[rd,-N.,H={pos=.35}] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                & \zxX{\alpha}
                                     \ar[ru,N'-,H={pos=1-.35}]
                                     \ar[rd,N.-,H={pos=1-.35}] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H={pos=.35}]                                &  & \zxN{}
\end{ZX}
\end{codeexample}
Note that it's possible to automatically start wires on the border of the node, but it is slower and create other issues, see \cref{subsec:wiresInsideOutside} for more details. The second option (also presented in this section) is to manually define the |start anchor| and |end anchor|, but it can change the shape of the wire).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/wire centered\@nil%
  \extractkey/zx/wires definition/wc\@nil%
  \extractkey/zx/wires definition/wire centered start\@nil%
  \extractkey/zx/wires definition/wcs\@nil%
  \extractkey/zx/wires definition/wire centered end\@nil%
  \extractkey/zx/wires definition/wce\@nil%
  \makeatother
  \pgfmanualbody
  Forces the wires to start at the center of the node (|wire centered start|, alias |wcs|), to end at the center of the node (|wire centered end|, alias |wce|) or both (|wire centered|, alias |wc|). This may be useful, for instance in the old |IO| mode (see below) when nodes have different sizes (the result looks strange otherwise), or with some wires (like |C|) connected to |\ZxNone+| (if possible, use |\zxNone| (without any embellishment) since it does not suffer from this issue as it is a coordinate).

  See also |between none| to also increase looseness when connecting only wires (use |between none| \emph{only} in |IO| mode).
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxZ{} \ar[IO,o',r] \ar[IO,o.,r]       & \zxX{\alpha}\\
  \zxZ{} \ar[IO,o',r,wc] \ar[IO,o.,r,wc] & \zxX{\alpha}
\end{ZX}
\end{codeexample}
% Without |wc| (note that because there is no node, we need to use |&[\zxWCol]| (for columns) and |\\[\zxWRow]| (for rows) to get nicer spacing):
% \begin{codeexample}[width=3cm]
% \zx{\zxNone{} \rar &[\zxWCol] \zxNone{} \rar &[\zxWCol] \zxNone{} }
% \end{codeexample}
% With |wc|:
% \begin{codeexample}[width=3cm]
% \zx{\zxNone{} \rar[wc] &[\zxWCol] \zxNone{} \rar[wc] &[\zxWCol] \zxNone{}}
% \end{codeexample}
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/bezier=-andL config \@nil%
  \extractkey/zx/wires definition/bezier x=-andL config \@nil%
  \extractkey/zx/wires definition/bezier y=-andL config \@nil%
  \extractkey/zx/wires definition/bezier 4=\{x1\}\{y1\}\{x2\}\{y2\} \@nil%
  \extractkey/zx/wires definition/bezier 4 x=\{x1\}\{y1\}\{x2\}\{y2\} \@nil%
  \extractkey/zx/wires definition/bezier 4 y=\{x1\}\{y1\}\{x2\}\{y2\} \@nil%
  \makeatother
  \pgfmanualbody
  To create a bezier wire. These styles are not really meant to be used for the final user because they are long to type and would not be changed document-wise when the style is changed, but most styles are based on these styles. For the |bezier 4 *| versions, the two first arguments are the relative position of the first anchor (|x| and |y| position), the next two of the second anchor. In the |bezier *| versions, the value of |1-| will be the relative |x| position of the first point, |1L| the relative position of the second, and |2-| and |2L| will be for the second point (the advantage of this is that it is also possible to specify angles using |1al={angle}{length}|\dots{} as explained in the |-andL| syle). They are said to be relative in the sense that |{0}{0}| is the coordinate of the first point, and |{1}{1}| the second point. The |bezier x| and |bezier 4 y| are useful when the node are supposed to be horizontally or vertically aligned: the distance are now expressed as a fraction of the horizontal (respectively vertical) distance between the two nodes. Using relative coordinates has the advantage that if the nodes positions are moved, the aspect of the wire does not change (it is just squeezed), while this is not true with |in|/|out| wires which preserves angles but not shapes.
\end{pgfmanualentry}


\subsubsection{IO wires, the old styles}\label{subsub:IOwires}

\begin{stylekey}{/zx/wires definition/IO}
As explained above, wires were first defined using |in|, |out| and |looseness|, but this turned out to be sometimes hard to use since the shape of the wire was changing depending on the position. For example consider the differences between the older version:
\begin{codeexample}[]
\begin{ZX}
  \zxN{}                       & \zxZ{} \\
  \zxZ{} \ar[ru,IO,N'] \ar[rd,IO,N.] &\\
                               & \zxZ{} \\
\end{ZX}
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-3pt]
  \zxZ{} \ar[ru,IO,N'] \ar[rd,IO,N.] &\\[-3pt]
                               & \zxZ{} \\
\end{ZX}
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-5pt]
  \zxZ{} \ar[ru,IO,N'] \ar[rd,IO,N.] &\\[-5pt]
                               & \zxZ{} \\
\end{ZX}
\end{codeexample}
\begin{codeexample}[]
\begin{ZX}
  \zxN{}                       & \zxZ{} \\
  \zxZ{} \ar[ru,N'] \ar[rd,N.] &\\
                               & \zxZ{} \\
\end{ZX}
and the newer:
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-3pt]
  \zxZ{} \ar[ru,N'] \ar[rd,N.] &\\[-3pt]
                               & \zxZ{} \\
\end{ZX}
\begin{ZX}
  \zxN{}                       & \zxZ{} \\[-5pt]
  \zxZ{} \ar[ru,N'] \ar[rd,N.] &\\[-5pt]
                               & \zxZ{} \\
\end{ZX}
\end{codeexample}
Here is another example:
\begin{codeexample}[]
Before \begin{ZX}
  \zxNone{} \ar[IO,C,d,wc] \ar[rd,IO,s] &[\zxWCol] \zxNone{} \\[\zxWRow]
  \zxNone{}                \ar[ru,IO,s] &          \zxNone{}
\end{ZX} after \begin{ZX}
  \zxNone{} \ar[C,d] \ar[rd,s] &[\zxWCol] \zxNone{} \\[\zxWRow]
  \zxNone{}          \ar[ru,s] &          \zxNone{}
\end{ZX}
\end{codeexample}
This example led to the creation of the |bn| style, in order to try to find appropriate looseness values depending on the case\dots{} but it is harder to use and results are less predictable.

The new method also allowed us to use |N| for both |N.| and |N'| styles (however we kept both versions for backward compatibility and in case later we want to make a distinction between nodes going doing or up).

However, if you prefer the old style, you can just use them by adding |IO,| in front of the style name (styles are nested inside |IO|). Note however that the customization options are of course different.
\end{stylekey}

We list now the older |IO| styles:

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/C\@nil%
  \extractkey/zx/wires definition/IO/C\@nil%
  \extractkey/zx/wires definition/IO/C'\@nil%
  \extractkey/zx/wires definition/IO/C-\@nil%
  \makeatother
  \pgfmanualbody
  |IO| mode for the |C| wire (used for Bell-like shapes).
\begin{codeexample}[]
  Bell pair \zx{\zxNone{} \ar[d,IO,C] \\[\zxWRow]
                \zxNone{}}
  and funny graph
  \begin{ZX}
    \zxX{} \ar[d,IO,C] \ar[r,C']  & \zxZ{} \ar[d,IO,C-]\\
    \zxZ{} \ar[r,IO,C.]           & \zxX{}
  \end{ZX}.
\end{codeexample}
Note that the |IO| version cannot really be used when nodes are not aligned (using |wc| can sometimes help with the alignment):
\begin{codeexample}[]
  Normal \begin{ZX}
    \zxX{\alpha} \ar[dr,C]\\
    & \zxNone{}
  \end{ZX}, and |IO| \begin{ZX}
    \zxX{\alpha} \ar[dr,IO,C]\\
    & \zxNone{}
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/o'=angle (default 40)\@nil%
  \extractkey/zx/wires definition/IO/o.=angle (default 40)\@nil%
  \extractkey/zx/wires definition/IO/o-=angle (default 40)\@nil%
  \extractkey/zx/wires definition/IO/-o=angle (default 40)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |o|. Curved wire, similar to |C| but with a soften angle (optionally specified via \meta{angle}, and globally editable with |\zxDefaultLineWidth|). Again, the symbols specify which part of the circle (represented with |o|) must be kept.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[d,IO,-o] \ar[d,IO,o-]\\
    \zxZ{} \ar[r,IO,o'] \ar[r,IO,o.] & \zxX{}
  \end{ZX}.
\end{codeexample}
 Note that these wires can be combined with |H|, |X| or |Z|, in that case one should use appropriate column and row spacing as explained in their documentation:
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[d,IO,-o,H] \ar[d,IO,o-,H]\\[\zxHRow]
    \zxZ{\beta} \rar & \zxZ{} \ar[r,IO,o',X] \ar[r,IO,o.,Z] &[\zxSCol] \zxX{}
  \end{ZX}.
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/(=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/)=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/('=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/('=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |(| (so far they are the same, but it may change later, use this version if you want to play with |looseness|). Curved wire, similar to |o| but can be used for diagonal items. The angle is, like in |bend right|, the opening angle from the line which links the two nodes. For the first two commands, the |(| and |)| symbols must be imagined as if the starting point was on top of the parens, and the ending point at the bottom.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{} \ar[rd,IO,(] \ar[rd,IO,),red]\\
    & \zxZ{}
  \end{ZX}.
\end{codeexample}
Then, |('|=|(| and |(.|=|)|; this notation is, I think, more intuitive when linking nodes from left to right. |('| is used when going to top right and |(.| when going to bottom right.
\begin{codeexample}[width=3cm]
\begin{ZX}
  \zxN{}                       & \zxX{}\\
  \zxZ{} \ar[ru,IO,('] \ar[IO,rd,(.] & \\
                               & \zxX{}
\end{ZX}
\end{codeexample}
When the nodes are too far appart, the default angle of |30| may produce strange results as it will go above (for |('|) the vertical line. Either choose a shorter angle, or see |<'| instead.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/s\@nil%
  \extractkey/zx/wires definition/IO/s'=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/s.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/-s'=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/-s.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/s'-=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/s.-=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |s|. |s| is used to create a s-like wire, to have nicer soften diagonal lines between nodes. Other versions are soften versions (the input and output angles are not as sharp, and the difference angle can be configured as an argument or globally using |\zxDefaultSoftAngleS|). Adding |'| or |.| specifies if the wire is going up-right or down-right.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,s,rd] \\
                               & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,s.,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,s,ru] \\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,s',ru] \\
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,-s.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,s.-,rd] \\
                           & \zxZ{\beta}\\
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/ss\@nil%
  \extractkey/zx/wires definition/IO/ss.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/.ss=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/sIs.=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/.sIs=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/ss.I-=angle (default 30)\@nil%
  \extractkey/zx/wires definition/IO/I.ss-=angle (default 30)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |ss|. |ss| is similar to |s| except that we go from top to bottom instead of from left to right. The position of |.| says if the node is wire is going bottom right (|ss.|) or bottom left (|.ss|).
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,ss.,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[IO,.ss,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[IO,.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
|I| forces the angle above (if in between the two |s|) or below (if on the same side as |.|) to be vertical.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,ss,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,sIs.,rd] \\
                           & \zxZ{\beta}\\
    \zxX{\alpha} \ar[IO,ss.I,rd] \\
                           & \zxZ{\beta}\\
                           & \zxX{\beta} \ar[IO,.sIs,dl] \\
    \zxZ{\alpha}\\
                           & \zxX{\beta} \ar[IO,I.ss,dl] \\
    \zxZ{\alpha}\\
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/<'=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/<.=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/'>=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/.>=angle (default 60)\@nil%
  %\extractkey/zx/wires definition/IO/^.=angle (default 60)\@nil%
  %\extractkey/zx/wires definition/IO/.^=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/'v=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/v'=angle (default 60)\@nil%
  \makeatother
  \pgfmanualbody
  These keys are a bit like |('| or |(.| but the arrival angle is vertical (or horizontal for the |^| (up-down) and |v| (down-up) versions). As before, the position of the decorator |.|,|'| denote the direction of the wire.
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{}                         & \zxZ{}\\
  \zxX{} \ar[IO,ru,<'] \ar[IO,rd,<.] \\
  \zxN{}                         & \zxZ{}\\
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxN{} & \zxFracX{\pi}{2} \ar[IO,dl,.^] \ar[IO,dr,^.] & \\
  \zxZ{} &                                & \zxX{}
\end{ZX}
\end{codeexample}
\begin{codeexample}[width=0cm]
\begin{ZX}
  \zxZ{} &                                & \zxX{}\\
  \zxN{} & \zxX{} \ar[IO,ul,'v] \ar[IO,ur,v'] &
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/IO/N'=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/N.=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/-N'=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/-N.=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/N'-=angle (default 60)\@nil%
  \extractkey/zx/wires definition/IO/N.-=angle (default 60)\@nil%
  \makeatother
  \pgfmanualbody
  |IO| version of |N|. |N| is used to create a wire leaving at wide angle and arriving at wide angle. Adding |'| or |.| specifies if the wire is going up-right or down-right.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,N.,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,N',ru] \\
  \end{ZX}
\end{codeexample}
|-| forces the angle on the side of |-| to be horizontal.
\begin{codeexample}[width=3cm]
  \begin{ZX}
    \zxX{\alpha} \ar[IO,-N.,rd] \\
                               & \zxZ{\beta}\\
                               & \zxZ{\alpha}\\
    \zxX{\beta} \ar[IO,N'-,ru] \\
  \end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\begin{stylekey}{/zx/wires definition/ls=looseness}
  Shortcut for |looseness|, allows to quickly redefine looseness. Use with care (or redefine style directly), and \emph{do not use on styles that are not in |IO|}, since they don't use the |in|/|out| mechanism (only |(|-like styles use |in|/|out|\dots{} for now. In case you want to change looseness of |(|, prefer to use |IO,(| as it is guaranteed to be backward compatible). We may try later to give a key |looseness| for these styles, but it's not the case for now. For |IO| styles, you can also change yourself other values, like |in|, |out|\dots
\begin{codeexample}[]
\begin{ZX}
  \zxZ{} \ar[rd,s] \\
                   & \zxX{}\\
  \zxZ{} \ar[rd,IO,s] \\
                   & \zxX{}\\
  \zxZ{} \ar[rd,IO,s,ls=3] \\
                   & \zxX{}
\end{ZX}
\end{codeexample}
\end{stylekey}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/wires definition/between none\@nil%
  \extractkey/zx/wires definition/bn\@nil%
  \makeatother
  \pgfmanualbody
  When drawing only |IO| wires (normal wires would suffer from this parameter), the default looseness may not be good looking and holes may appear in the line. This style (whose alias is |bn|) should therefore be used when curved wires \emph{from the |IO| path} are connected together. In that case, also make sure to separate columns using |&[\zxWCol]| and rows using |\\[\zxWRow]|.
\begin{codeexample}[width=3cm]
A swapped Bell pair is %
\begin{ZX}
  \zxNone{} \ar[IO,C,d,wc] \ar[rd,IO,s,bn] &[\zxWCol] \zxNone{} \\[\zxWRow]
  \zxNone{}                \ar[ru,IO,s,bn] &          \zxNone{}
\end{ZX}
\end{codeexample}
\end{pgfmanualentry}

\section{Advanced styling}

\subsection{Overlaying or creating styles}

It is possible to arbitrarily customize the styling, create or update ZX or tikz styles\dots{} First, any option that can be given to a |tikz-cd| matrix can also be given to a |ZX| environment (we refer to the manual of |tikz-cd| for more details). We also provide overlays to quickly modify the ZX style.

\begin{stylekey}{/zx/default style nodes}
  This is where the default style must be loaded. By default, it simply loads the (nested) style packed with this library, |/zx/styles/rounded style|. You can change the style here if you would like to globally change a style.

  Note that a style must typically define at least |zxZ4|, |zxX4|, |zxFracZ6|, |zxFracX6|, |\zxH|, |zxHSmall|, |zxNoPhaseSmallZ|, |zxNoPhaseSmallX|, |zxNone{,+,-,I}|, |zxNoneDouble{,+,-,I}| and all the |phase in label*|, |pil*| styles (see code on how to define them). Because the above styles (notably |zxZ*| and |zxFrac*|) are slightly complex to define (this is needed in order to implement |phase in label|, |-| versions\dots{}), it may be quite long to implement them all properly by yourself.

  For that reason, it may be easier to load our default style and overlay only some of the styles we use (see example in |/zx/user overlay nodes| right after). You can check our code in |/zx/styles/rounded style| to see what you can redefine (intuitively, the styles like |my style name| should be callable by the end user, |myStyleName| may be redefined by users or used in tikzit, and |my@style@name| are styles that should not be touched by the user). The styles that have most interests are |zxNoPhase| (for Z and X nodes without any phase inside), |zxShort| (for Z and X nodes for fractions typically), |zxLong| (for other Z and X nodes) and |stylePhaseInLabel| (for labels when using |phase in label|). These basic styles are extended to add colors (just add |Z|/|X| after the name) like |zxNoPhaseZ|\dots{} You can change them, but if you just want to change the color, prefer to redefine |colorZxZ|/|colorZxZ| instead (note that this color does not change |stylePhaseInLabelZ/X|, so you are free to redefine these styles as well). All the above styles can however be called from inside a tikzit style, if you want to use tikzit internally (make sure to load this library then in |*.tikzdefs|).

  Note however that you should avoid to call these styles from inside |\zx{...}| since |\zx*| and |\zxFrac*| are supposed to choose automatically the good style for you depending on the mode (fractions, labels in phase\dots{}). For more details, we encourage the advanced users too look at the code of the library, and examples for simple changes will be presented now.
\end{stylekey}

\begin{stylekey}{/zx/user overlay nodes}
  If a user just wants to overlay some parts of the node styles, add your changes here.
\begin{codeexample}[]
  {\tikzset{
      /zx/user overlay nodes/.style={
        zxH/.append style={dashed,inner sep=2mm}
      }}
    \zx{\zxNone{} \rar & \zxH{} \rar & \zxNone{}}
  }
\end{codeexample}
You can also change it on a per-diagram basis:
\begin{codeexample}[]
  \zx[text=yellow,/zx/user overlay nodes/.style={
    zxSpiders/.append style={thick,draw=purple}}
  ]{\zxX{} \rar & \zxX{\alpha} \rar & \zxFracZ-{\pi}{2}}
\end{codeexample}
The list of keys that can be changed will be given below in |/zx/styles/rounded style/*|.
\end{stylekey}

\begin{stylekey}{/zx/default style wires}
  Default style for wires. Note that |/zx/wires definition/| is always loaded by default, and we don't add any other style for wires by default. But additional styles may use this functionality.
\end{stylekey}

\begin{stylekey}{/zx/user overlay wires}
  The user can add here additional styles for wires.
\begin{codeexample}[]
\begin{ZX}[/zx/user overlay wires/.style={thick,->,C/.append style={dashed}}]
  \zxNone{} \ar[d,C] \rar[] &[\zxWCol] \zxNone{}\\[\zxWRow]
  \zxNone{} \rar[] & \zxNone{}
\end{ZX}
\end{codeexample}
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style}
  This is the style loaded by default. It contains internally other (nested) styles that must be defined for any custom style.
\end{stylekey}

We present now all the properties that a new node style must have (and that can overlayed as explained above).
\begin{stylekey}{/zx/styles/rounded style/zxAllNodes}
  Style applied to all nodes.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxEmptyDiagram}
  Style to draw an empty diagram.
\end{stylekey}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/zxNone\@nil%
  \extractkey/zx/styles/rounded style/zxNone+\@nil%
  \extractkey/zx/styles/rounded style/zxNone-\@nil%
  \extractkey/zx/styles/rounded style/zxNoneI\@nil%
  \makeatother
  \pgfmanualbody
  Styles for None wires (no inner sep, useful to connect to wires). The |-|,|I|,|+| have additional horizontal, vertical, both spaces.
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/zxNoneDouble\@nil%
  \extractkey/zx/styles/rounded style/zxNoneDouble+\@nil%
  \extractkey/zx/styles/rounded style/zxNoneDouble-\@nil%
  \extractkey/zx/styles/rounded style/zxNoneDoubleI\@nil%
  \makeatother
  \pgfmanualbody
  Like |zxNone|, but with more space to fake two nodes on a single line (not very used).
\end{pgfmanualentry}

\begin{stylekey}{/zx/styles/rounded style/zxSpiders}
  Style that apply to all circle spiders.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxNoPhase}
  Style that apply to spiders without any angle inside. Used by |\zxX{}| when the argument is empty.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxNoPhaseSmall}
  Like |zxNoPhase| but for spiders drawn in between wires.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxShort}
  Spider with text but no inner space. Used notably to obtain nice fractions.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxLong}
  Spider with potentially large text. Used by |\zxX{\alpha}| when the argument is not empty.
\end{stylekey}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/styles/rounded style/zxNoPhaseZ\@nil%
  \extractkey/zx/styles/rounded style/zxNoPhaseX\@nil%
  \extractkey/zx/styles/rounded style/zxNoPhaseSmallZ\@nil%
  \extractkey/zx/styles/rounded style/zxNoPhaseSmallX\@nil%
  \extractkey/zx/styles/rounded style/zxShortZ\@nil%
  \extractkey/zx/styles/rounded style/zxShortX\@nil%
  \extractkey/zx/styles/rounded style/zxLongZ\@nil%
  \extractkey/zx/styles/rounded style/zxLongX\@nil%
  \makeatother
  \pgfmanualbody
  Like above styles, but with colors of |X| and |Z| spider added. The color can be changed globally by updating the |colorZxX| color. By default we use:
  \begin{verse}
    |\definecolor{colorZxZ}{RGB}{204,255,204}|\\
    |\definecolor{colorZxX}{RGB}{255,136,136}|\\
    |\definecolor{colorZxH}{RGB}{255,255,0}|
  \end{verse}
  as the second recommendation in \href{https://zxcalculus.com/accessibility.html}{\texttt{zxcalculus.com/accessibility.html}}.
\end{pgfmanualentry}

\begin{stylekey}{/zx/styles/rounded style/zxH}
  Style for Hadamard spiders, used by |\zxH{}| and uses the color |colorZxH|.
\end{stylekey}

\begin{stylekey}{/zx/styles/rounded style/zxHSmall}
  Like |zxH| but for Hadamard on wires, (see |H| style).
\end{stylekey}

\begin{pgfmanualentry}
  \extractcommand\zxConvertToFracInContent\marg{sign}\marg{num no parens}\marg{denom no parens}\marg{nom parens}\marg{denom parens}\@@
  \extractcommand\zxConvertToFracInLabel\@@
  \pgfmanualbody
  These functions are not meant to be used, but redefined using something like (we use |\zxMinus| as a shorter minus compared to $-$):
\begin{verse}
  |\RenewExpandableDocumentCommand{\zxConvertToFracInLabel}{mmmmm}{%|\\
  |  \ifthenelse{\equal{#1}{-}}{\zxMinus}{#1}\frac{#2}{#3}%|\\
  |}|
\end{verse}
This is used to change how the library does the conversion between |\zxFrac| and the actual written text (either in the node content or in the label depending on the function). The first argument is the sign (string |-| for minus, anything else must be written in place of the minus), the second and third argument are the numerator and denominator of the fraction when used in |\frac{}{}| while the last two arguments are the same except that they include the parens which should be added when using an inline version. For instance, one could get a call |\zxConvertToFracInLabel{-}{a+b}{c+d}{(a+b)}{(c+d)}|. See part on labels to see an example of use.
\end{pgfmanualentry}

\begin{command}{\zxMinusInShort}
  Sign used in |\zxZ-{\alpha}| and |\zxX-{\alpha}|-like patterns. You can redefine it, for instance:
\begin{codeexample}[]
Compare {\def\zxMinusInShort{-}
  \zx{\zxZ-{\alpha}}
} and
{\def\zxMinusInShort{\zxMinus}
  \zx{\zxZ-{\alpha}}
}
\end{codeexample}
\end{command}

\noindent We also define several spacing commands that can be redefined to your needs:
\begin{pgfmanualentry}
  \extractcommand\zxHCol{}\@@
  \extractcommand\zxHRow{}\@@
  \extractcommand\zxHColFlat{}\@@
  \extractcommand\zxHRowFlat{}\@@
  \extractcommand\zxSCol{}\@@
  \extractcommand\zxSRow{}\@@
  \extractcommand\zxSColFlat{}\@@
  \extractcommand\zxSRowFlat{}\@@
  \extractcommand\zxHSCol{}\@@
  \extractcommand\zxHSRow{}\@@
  \extractcommand\zxHSColFlat{}\@@
  \extractcommand\zxHSRowFlat{}\@@
  \extractcommand\zxWCol{}\@@
  \extractcommand\zxWRow{}\@@
  \extractcommand\zxwCol{}\@@
  \extractcommand\zxwRow{}\@@
  \extractcommand\zxDotsCol{}\@@
  \extractcommand\zxDotsRow{}\@@
  \extractcommand\zxZeroCol{}\@@
  \extractcommand\zxZeroRow{}\@@
  \extractcommand\zxNCol{}\@@
  \extractcommand\zxNRow{}\@@
  \pgfmanualbody
  These are spaces, to use like |&[\zxHCol]| or |\\[\zxHRow]| in order to increase the default spacing of rows and columns depending on the style of the wire. |H| stands for Hadamard, |S| for Spiders, |W| for Wires only, |w| is you link a |zxNone| to a spider (goal is to increase the space), |N| is when you have a |\zxN| and want to reduce the space between columns, |HS| for both Spiders and Hadamard, |Dots| for the 3 dots styles, |Zero| completely resets the default column sep. And of course |Col| for columns, |Row| for rows.
\begin{codeexample}[width=3cm]
\begin{ZX}
 \zxN{} \ar[rd,-N.] &[\zxwCol]    &[\zxwCol] \zxN{} \\[\zxNRow]%%
                    & \zxX{\alpha}
                      \ar[ru,N'-]
                      \ar[rd,N.-] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N']               &  & \zxN{}
\end{ZX}
\end{codeexample}
Note that you can add multiple of them by separating with commas (see |\pgfmatrixnextcell|'s documentation for more details). For instance to have a column separation of exactly |2mm|, do |&[\zxZeroCol,2mm]| (if you just do |&[2mm]| the column will be |2mm| larger).
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxDefaultColumnSep{}\@@
  \extractcommand\zxDefaultRowSep{}\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/defaultEnv/zx column sep=length\@nil%
  \extractkey/zx/defaultEnv/zx row sep=length\@nil%
  \makeatother
  \pgfmanualbody
  |\zxDefaultColumn/RowSep| are the column and row space, and the corresponding styles are to change a single matrix. Prefer to change these parameters compared to changing the |row sep| and |column sep| (without |zx|) of the matrix directly since other spacing styles like |\zxZeroCol| or |\zxNCol| depend on |\zxDefaultColumn|.
\end{pgfmanualentry}


\begin{pgfmanualentry}
  \extractcommand\zxDefaultSoftAngleS{}\@@
  \extractcommand\zxDefaultSoftAngleO{}\@@
  \extractcommand\zxDefaultSoftAngleChevron{}\@@
  \pgfmanualbody
  Default opening angles of |S|, |o| and |v|/|<| wires. Defaults to respectively $30$, $40$ and $45$.
\end{pgfmanualentry}

\begin{command}{\zxMinus{}}
  The minus sign used in fractions.
\end{command}

\subsection{Wire customization}\label{subsec:wirecustom}

\begin{pgfmanualentry}
  \makeatletter
  \def\extrakeytext{style, }
  \extractkey/zx/args/-andL/\@nil%
  \extractkey/zx/args/-andL/defaultO (default {-=.2,L=.4})\@nil%
  \extractkey/zx/args/-andL/defaultN (default {-=.2,L=.8})\@nil%
  \extractkey/zx/args/-andL/defaultN- (default {1-=.4,1L=0})\@nil%
  \extractkey/zx/args/-andL/defaultNN (default {})\@nil%
  \extractkey/zx/args/-andL/defaultNIN (default {1-=0,1L=.6})\@nil%
  \extractkey/zx/args/-andL/defaultS (default {-=.8,L=0})\@nil%
  \extractkey/zx/args/-andL/defaultS' (default {-=.8,L=.2})\@nil%
  \extractkey/zx/args/-andL/default-S (default {1-=.8,1L=0})\@nil%
  \extractkey/zx/args/-andL/defaultSIS (default {1-=0,1L=.8})\@nil%
  \makeatother
  \pgfmanualbody
  Default values used by wires (). You can customize them globally using something like:
  \begin{verse}
    |\tikzset{|\\
    |  /zx/args/-andL/.cd,|\\
    |  defaultO/.style={-=.2,L=.4}|\\
    |}|
   \end{verse}
   Basically |defaultO| will configure all the |o| familly, |defaultS'| will configure all the ``soft'' versions of |s|, |default-S| will configure the anchor on the side of the vertical arrival\dots{} For more details or which wire uses which configuration, check the default value given in each style definition.
\end{pgfmanualentry}

\subsection{Wires starting inside or on the boundary of the node}\label{subsec:wiresInsideOutside}

This library provides multiple methods to draw the wires between the nodes (for all curves depending on |bezier|, which is basically everything but |C| and straight lines).

\paragraph{Default drawing method.}
By default the lines will be drawn behind the node and the starting and ending points will be defined to be a |fake center *| anchor (if it exists, the exact chosen anchors (north, south\dots{}) depending on the direction). Because this anchor lies behind the node, we put them on the |edgelayer| layer. For debugging purpose, it can be practical to display them:
\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxEdgesAbove\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/edge above\@nil%
  \extractkey/zx/wires definition/edge not above\@nil%
  \makeatother
  \pgfmanualbody
  If the macro |\zxEdgesAbove| is undefined (using |\let\zxEdgesAbove\undefined|) edges will be drawn above the nodes. To change it on a per-edge basis, use |edge above| (or its contrary |edge not above|) \emph{before the name of the wire}. This is mostly useful to understand how lines are drawn and for debugging purpose.
\begin{codeexample}[]
  What you see:
  \zx{\zxZ{\alpha+\beta} \ar[dr,s] \\
                         & \zxZ{\alpha+\beta}}
  What is drawn:
  \zx{\zxZ{\alpha+\beta} \ar[dr,edge above,s] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
(you can node the fact that the wire does not start at the center but at a |fake center *| anchor to provide a nicer look)
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxControlPointsVisible\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/control points visible\@nil%
  \extractkey/zx/wires definition/control points not visible\@nil%
  \makeatother
  \pgfmanualbody
  Similarly, it can be useful for debugging to see the control points of the curves (note that |C|, straight lines and |(| wires are not based on our curve system, so it won't do anything for them). If the macro |\zxControlPointsVisible| is defined (using |\def\zxEdgesAbove{}|) control points will be drawn. To change it on a per-edge basis, use |control points visible| (or its contrary |control points not visible|). This is mostly useful to understand how lines are drawn and for debugging purpose.
\begin{codeexample}[]
  Controls not visible:
  \zx{\zxZ{\alpha+\beta} \ar[dr,s] \\
                         & \zxZ{\alpha+\beta}}
  Control visible:
  \zx{\zxZ{\alpha+\beta} \ar[dr,control points visible,s] \\
                         & \zxZ{\alpha+\beta}}
  Control visible + edge above:
  \zx{\zxZ{\alpha+\beta} \ar[dr,edge above,control points visible,s] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
\textbf{WARNING}: this command adds some points in the wire path, and in particular if you have a |H| wire (Hadamard in the middle of the wire), this option will not place it correctly. But it's not really a problem since it's just to do a quick debugging.
\end{pgfmanualentry}

Unfortunately, the default drawing method also has drawbacks. For instance, when using the |H| edge between a spider and an empty node, the ``middle'' of the edge will appear too close to the center by default (we draw the first edge above to illustrate the reason of this visual artifact):
\begin{codeexample}[width=0cm]
\begin{ZX}
 \zxN{} \ar[rd,edge above,-N.,H] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                 & \zxX{\alpha}
                                   \ar[ru,N'-,H]
                                   \ar[rd,N.-,H] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H]                        &  & \zxN{}
\end{ZX}
\end{codeexample}
To solve that issue, you need to manually position the |H| node as shown before:
\begin{codeexample}[width=0cm]
\begin{ZX}
 \zxN{} \ar[rd,edge above,-N.,H={pos=.35}] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                           & \zxX{\alpha}
                                             \ar[ru,N'-,H={pos=1-.35}]
                                             \ar[rd,N.-,H={pos=1-.35}] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H={pos=.35}]                                  &  & \zxN{}
\end{ZX}
\end{codeexample}
Or manually position the anchor outside the node (you can use angles, centered on the real center on the shape), but be aware that it can change the shape of the node (see below):
\begin{codeexample}[width=0cm]
\begin{ZX}
 \zxN{} \ar[rd,edge above,-N.,H,end anchor=180-45] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                           & \zxX{\alpha}
                                             \ar[ru,N'-,H,start anchor=45]
                                             \ar[rd,N.-,H,start anchor=-45] &  \\[\zxNRow]
 \zxN{} \ar[ru,-N',H,end anchor=180+45]                                  &  & \zxN{}
\end{ZX}
\end{codeexample}

A second drawback is that it is not possible to add arrows on the curved wires (except |C| which uses a different approach), since they will be hidden behind the node:
\begin{codeexample}[]
  What you see:
  \zx{\zxZ{\alpha+\beta} \ar[dr,s,<->] \\
                         & \zxZ{\alpha+\beta}}
  What is drawn:
  \zx{\zxZ{\alpha+\beta} \ar[dr,edge above,s,<->] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
Here, the only solution (without changing the drawing mode) is to manually position the anchor as before\dots{} but note that on nodes with a large content |45| degrees is actually nearly on the top since the angle is not taken from a fake center but from the real center of the node.
\begin{codeexample}[]
  \zx{\zxZ{\alpha+\beta} \ar[dr,s,<->,start anchor=-45,end anchor=180-45] \\
                         & \zxZ{\alpha+\beta}}
  \zx{\zxZ{\alpha+\beta} \ar[dr,s,<->,start anchor=-15,end anchor=180-15] \\
                         & \zxZ{\alpha+\beta}}
\end{codeexample}
 Note that the shape of the wire may be a bit different since the ending and leaving parts was hidden before, and the current styles are not designed to look nicely when starting on the border of a node. For that reason, you may need to tweak the style of the wire yourself using |-|, |L| options.

 \paragraph{The ``intersection'' drawing methods}

 We also define other modes to draw wires (they are very new and not yet tested a lot). In the first mode, appropriate |fake center *| is taken, then depending on the bezier control points, a point is taken on the border of the shape (starting from the fake center and using the direction of the bezier control point). Then the node is drawn. Here is how to enable this mode:

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxEnableIntersections\marg{}\@@
  \extractcommand\zxDisableIntersections\marg{}\@@
  \extractcommand\zxEnableIntersectionsNodes\@@
  \extractcommand\zxEnableIntersectionsWires\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/use intersections\@nil%
  \extractkey/zx/wires definition/dont use intersections\@nil%
  \makeatother
  \pgfmanualbody
  The simpler method to enables or disable intersections is to call |\zxEnableIntersections{}| or |\zxDisableIntersections{}| (potentially in a group to have a local action only). Note that \emph{this does not automatically adapt the styles}, see |ui| to adapt the styles automatically.
\begin{codeexample}[width=0cm]
{% Enable intersections (but does not load our custom "intersections" style, see ui).
  \zxEnableIntersections{}% Small space left = artifact of the documentation
  \begin{ZX}
    \zxN{} \ar[rd,edge above,-N.,H] &[\zxwCol,\zxHCol] &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                    & \zxX{\alpha}
                                      \ar[ru,N'-,H]
                                      \ar[rd,N.-,H]    &  \\[\zxNRow]
    \zxN{} \ar[ru,-N',H]            &                  & \zxN{}
  \end{ZX}
}
\end{codeexample}
(The |edge above| is just to show that the wire does not go inside.) However, this method enable intersections for the whole drawing. You can disable it for a single arrow using the |dont use intersections| style. But it is possible instead to enable it for a single wire. To do that, first define |\def\zxEnableIntersectionsNodes{}| (it will automatically add a |name path| on each node. If you don't care about optimizations, you can just define it once at the beginning of your project), and then use |use intersections| on the wires which should use intersections:
\begin{codeexample}[width=0cm]
{% Create the machinary needed to compute intersections, but does not enable it.
  \def\zxEnableIntersectionsNodes{}% Small space left = artifact of the documentation
  \begin{ZX}
    \zxN{} \ar[rd,edge above,-N.,H, %% "use intersections" does not load any style, cf ui.
            use intersections] &[\zxwCol,\zxHCol]  &[\zxwCol,\zxHCol] \zxN{} \\[\zxNRow]%%
                                                   & \zxX{\alpha}
                                                     \ar[ru,edge above,N'-,H,use intersections]
                                                        \ar[rd,edge above,N.-,H]  &  \\[\zxNRow]
    \zxN{} \ar[ru,edge above,-N',H]                &                              & \zxN{}
  \end{ZX}
}
\end{codeexample}
\end{pgfmanualentry}

\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/ui\@nil%
  \makeatother
  \pgfmanualbody
  This method has however a few drawbacks. One of the first reason that explains why we don't use it by default is that it is quite long to compute (it involves the |intersections| library to obtain the bezier point to start at and my code may also be not very well optimized as I'm a beginner with \LaTeX{} and \tikzname{} programming\dots{} and what a strange language!). Secondly, it has not yet been tested a lot. Note also that the default wire styles have not been optimized for this setup and the results may vary compared to the default drawing mode (sometimes they are ``better'', sometimes they are not). We have however tried to define a second style |/zx/args/-andL/ui/| that have nicer results. To load it, just type |ui| \emph{before the wire style name}, it will automatically load |use intersections| together with our custom styles (see below how to use |user overlay wires| to load it by default):
%%% I'm not sure why, but inside codeexample if I write zxEnableIntersections{}%<go to line>\begin{ZX}... then an additional space is added... Not sure why.
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  Before \begin{ZX}
    \zxX{\beta} \ar[r,o'] & \zxX{}
  \end{ZX} after \begin{ZX}
    \zxX{\beta} \ar[r,o',use intersections] & \zxX{}
  \end{ZX} corrected manually \begin{ZX}
    \zxX{\beta} \ar[r,edge above, use intersections, o'={-=.2,L=.15}] & \zxX{}
  \end{ZX} or with our custom style \begin{ZX}
    \zxX{\beta} \ar[r,edge above, ui, o'] & \zxX{}
  \end{ZX}.
}
\end{codeexample}
Here are further comparisons:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  Before \begin{ZX}
    \zxX{} \ar[r,o'] & \zxX{}
  \end{ZX} ui \begin{ZX}
    \zxX{} \ar[r, ui, o'] & \zxX{}
  \end{ZX}. Before \begin{ZX}
    \zxX{\alpha} \ar[r,o'] & \zxZ{\beta}
  \end{ZX} ui \begin{ZX}
    \zxX{\alpha} \ar[r, ui, o'] & \zxZ{\beta}
  \end{ZX}. Before \begin{ZX}
    \zxX{\alpha+\beta} \ar[r,o'] & \zxZ{\alpha+\beta}
  \end{ZX} ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[r, ui, o'] & \zxZ{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}
With |N|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,N]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,N]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,N]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,N]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |N-|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,N-]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,N-]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N-]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N-]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N-]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,N-]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,N-]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,N-]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |<.|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,<.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,<.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,<.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,<.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,<.]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,<.]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,<.]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,<.]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |NIN|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,NIN]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,NIN]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,NIN]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,NIN]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,NIN]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,NIN]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,NIN]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,NIN]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With this mode |s| behaves basically like |S| since the only difference is the anchor:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,s]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,s]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |s'|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,s']\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,s']\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s']\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s']\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,s']\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,s']\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,s']\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,s']\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |-s|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,-s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,-s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,-s]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,-s]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,-s]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,-s]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,-s]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,-s]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |SIS|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,SIS]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,SIS]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,SIS]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,SIS]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,SIS]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,SIS]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,SIS]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,SIS]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

With |^.|:
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{} \ar[rd,^.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{} \ar[rd,ui,^.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,^.]\\ & \zxX{}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,^.]\\ & \zxX{}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[rd,^.]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha} \ar[rd,ui,^.]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,^.]\\ & \zxX{\alpha+\beta}
  \end{ZX} $\Rightarrow $ ui \begin{ZX}
    \zxX{\alpha+\beta} \ar[rd,ui,^.]\\ & \zxX{\alpha+\beta}
  \end{ZX}.
}
\end{codeexample}

Now using our favorite drawing. Here we illustrate how we apply our custom style to all arrows.
\begin{codeexample}[width=0pt]
\def\zxEnableIntersectionsNodes{}%
\tikzset{
  /zx/user overlay wires/.style={
    ui, % Other method
  }
}
\begin{ZX}[
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,'>]
  % Column 4
  \ar[from=toprightpi,to=mypi2,-N]
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[edge above,use intersections,from=Xdown,to=out3,<.]
\end{ZX}
\end{codeexample}

The same using |control points visible| to check if the good styles are applied:
\begin{codeexample}[width=0pt]
\def\zxEnableIntersectionsNodes{}%
\tikzset{
  /zx/user overlay wires/.style={
    ui, % Enable our style on all
    edge above, % For debugging
    control points visible % For debugging
  }
}
\def\zxDebugMode{}
\def\zxControlPointsVisible{}
\begin{ZX}[
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,'>]
  % Column 4
  \ar[from=toprightpi,to=mypi2,-N]
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[edge above,use intersections,from=Xdown,to=out3,<.]
\end{ZX}
\end{codeexample}

Now, we can also globally enable the |ui| style and the intersection only for some kinds of arrows. For instance (here we enable it for all styles based on |N|, i.e.\ |*N*| and |>|-like wires). See that the |s| node is note using the intersections mode:
\begin{codeexample}[width=0pt]
\def\zxEnableIntersectionsNodes{}%
\tikzset{
  /zx/user overlay wires/.style={
    %% Nbase changes both N-like and >-like styles.
    %% Use N/.append to change only N-like.
    Nbase/.append style={%
      ui, % intersection only for arrows based on N (N and <)
    },
    edge above, % For debugging
    control points visible % For debugging
  }
}
\def\zxDebugMode{}
\def\zxControlPointsVisible{}
\begin{ZX}[
  execute at begin picture={%
    %%% Definition of long items (the goal is to have a small and readable matrix
    % (warning: macro can't have numbers in TeX. Also, make sure not to use existing names)
    \def\Zpifour{\zxFracZ[a=Zpi4]-{\pi}{4}}%
    \def\mypitwo{\zxFracX[a=mypi2]{\pi}{2}}%
  }
  ]
  %%% Matrix: in emacs "M-x align" is practical to automatically format it. a is for 'alias'
  & \zxN[a=n]{}  & \zxZ[a=xmiddle]{}       &            & \zxN[a=out1]{} \\
  \zxN[a=in1]{} & \Zpifour{}   & \zxX[a=Xdown]{}         & \mypitwo{} &                \\
  &              &                         &            & \zxN[a=out2]{} \\
  \zxN[a=in2]{} & \zxX[a=X1]{} & \zxZ[a=toprightpi]{\pi} &            & \zxN[a=out3]{}
  %%% Arrows
  % Column 1
  \ar[from=in1,to=X1,s]
  \ar[from=in2,to=Zpi4,.>]
  % Column 2
  \ar[from=X1,to=xmiddle,N']
  \ar[from=X1,to=toprightpi,H]
  \ar[from=Zpi4,to=n,C] \ar[from=n,to=xmiddle,wc]
  \ar[from=Zpi4,to=Xdown]
  % Column 3
  \ar[from=xmiddle,to=Xdown,C-]
  \ar[from=xmiddle,to=mypi2,'>]
  % Column 4
  \ar[from=toprightpi,to=mypi2,-N]
  \ar[from=mypi2,to=out1,<']
  \ar[from=mypi2,to=out2,<.]
  \ar[edge above,use intersections,from=Xdown,to=out3,<.]
\end{ZX}
\end{codeexample}

\end{pgfmanualentry}


\begin{pgfmanualentry}
  \def\extrakeytext{style, }
  \extractcommand\zxIntersectionLineBetweenStartEnd\@@
  \makeatletter% should not be letter for \@@... strange
  \extractkey/zx/wires definition/intersections mode between start end\@nil%
  \extractkey/zx/wires definition/intersections mode bezier controls\@nil%
  \makeatother
  \pgfmanualbody

Node that we also defined another intersection mechanism, in which the intersection with the node boundary is computed using the line that links the two fake centers of the starting and ending point. To use it, either define |\def\zxIntersectionLineBetweenStartEnd{}| or use the style |intersections between start end| (or to come back to the normal intersection mode |intersections bezier controls|). Note that this just changes the mode of computing intersections, but does not enable intersections, you still need to enable intersections as explained above (for instance using |use intersection|, or |ui| if you also want to load our style). Note however that we don't spent too much effort in this mode as the result is often not really appealing, in particular the |o| shapes, and therefore we designed no special style for it and made only a few tests.
\begin{codeexample}[]
{%
  \def\zxEnableIntersectionsNodes{}
  \begin{ZX}
    \zxX{\alpha} \ar[rd,N]\\ & \zxX{\beta}
  \end{ZX} $\Rightarrow $ between start end \begin{ZX}
    \zxX{\alpha} \ar[edge above,rd,ui,intersections mode between start end,N]\\ & \zxX{\beta}
  \end{ZX}.
  \begin{ZX}
    \zxX{\alpha} \ar[r,o'] \ar[r,o.] & \zxX{\beta}
  \end{ZX} $\Rightarrow $ between start end \begin{ZX}
    \zxX{\alpha} \ar[r,ui,intersections mode between start end,o']
                 \ar[r,ui,intersections mode between start end,o.] & \zxX{\beta}
  \end{ZX}.
}
\end{codeexample}
\end{pgfmanualentry}

\subsection{Further customization}

You can further customize your drawings using any functionality from \tikzname{} and |tikz-cd| (but it is of course at your own risk). For instance, we can change the separation between rows and/or columns for a whole picture using:
\begin{codeexample}[width=0pt]
  \begin{ZX}[row sep=1mm]
                &                                         &                        & & \zxZ{\pi} \\
    \zxN{} \rar & \zxX{} \ar[rd,(.] \ar[urrr,(',H]        &                        & &  & \zxN{} \\
                &                                         & \zxZ{} \ar[rd,s.] \rar &
       \zxFracX{\pi}{2} \ar[uur,('] \ar[rru,<'] \ar[rr] &  & \zxN{} \\
    \zxN{} \rar & \zxFracZ-{\pi}{4} \ar[ru,('] \ar[rr,o.] &            & \zxX{} \ar[rr] &  & \zxN{}
  \end{ZX}
\end{codeexample}
Or we can define our own style to create blocks:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=0pt]
{ % \usetikzlibrary{shadows}
  \tikzset{
    my bloc/.style={
      anchor=center,
      inner sep=2pt,
      inner xsep=.7em,
      minimum height=3em,
      draw,
      thick,
      fill=blue!10!white,
      double copy shadow={opacity=.5},tape,
    }
  }
  \zx{|[my bloc]| f \rar &[1mm] |[my bloc]| g \rar &[1mm] \zxZ{\alpha} \rar & \zxNone{}}
}
\end{codeexample}
}
We can also use for instance |fit|, |alias|, |execute at end picture| and layers (the user can use |background| for things behind the drawing, |box| for special nodes above the drawings (like multi-column nodes, see below), and |foreground| which is even higher) to do something like that:
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=3cm]
% \usetikzlibrary{fit}
\begin{ZX}[
  execute at end picture={
    \node[
      inner sep=2pt,
      node on layer=background, %% Ensure the node is behind the drawing
      rounded corners,
      draw=blue,
      dashed,
      fill=blue!50!white,
      opacity=.5,
      fit=(cnot1)(cnot2), %% position of the node, thanks fit library
      "\textsc{cnot}" above %% Adds label, thanks quote library
    ] {};
  }
  ]
  \zxNone{} \rar & \zxZ[alias=cnot1]{} \dar \rar & \zxNone{}\\
  \zxNone{} \rar & \zxX[alias=cnot2]{} \rar      & \zxNone{}\\
\end{ZX}
\end{codeexample}
}
This can also be used to fake multi-columns nodes (I need to check later if I can facilitate this kind of operation from the library directly):
{\catcode`\|=12 % Ensures | is not anymore \verb|...|
\begin{codeexample}[width=3cm]
% \usetikzlibrary{fit}
\tikzset{
  my box/.style={inner sep=4pt, draw, thick, fill=white,anchor=center},
}
\begin{ZX}[
  execute at end picture={
    \node[
      my box,
      node on layer=box, %% Ensure the node is above the wires
      fit=(f1)(f2), %% position of the node, thanks fit library
      label={[node on layer=box]center:$f$},
    ] {};
  }
  ]
  \zxNoneDouble+[alias=f1]{} \rar &[1mm] |[my box]| g \rar & \zxNone{}\\
  \zxNoneDouble+[alias=f2]{} \rar &[1mm] \zxZ{} \rar       & \zxNone{}\\
\end{ZX}
\end{codeexample}
}

\section{Futur works}

There is surely many things to improve in this library, and given how young it is there is surely many undiscovered bugs. So feel free to propose ideas or report bugs \mylink{https://github.com/leo-colisson/zx-calculus/issues}{one the github page}. I also would like to provide externalization to boost compilation time. But |tikz-cd| is not really compatible with externalization, so it would need a bit of work (of course, you can always compile your images in a separate file, but it is cumbersome). See potential solutions here: \mylink{https://tex.stackexchange.com/questions/171931/}{here}. The intersections code is also quite slow, so I would be curious to check if I can optimize it (the first goal was to make it work). I should also work on the compatibility with tikzit (basically just write tikz configuration files that you can just use and document how to use tikzit with it), or even write a dedicated graphical tool (why not based on tikzit itself, or \mylink{https://tikzcd.yichuanshen.de/}{this tool}). And of course fix typos in the documentation and write other styles, including notations not specific to ZX-calculus. Feel free to submit Pull Requests to solve that!

\section{Acknowledgement}

I'm very grateful of course to everybody that worked on these amazing field which made diagramatic quantum computing possible, and to the many StackExchange users that helped me to understand a bit more \LaTeX{} and \tikzname{} (sorry, I don't want to risk an incomplete list, but many thanks to egreg, David Carlisle, cfr, percusse, Andrew Stacey, Henri Menke, SebGlav\dots{}). I also thank Robert Booth for making me realize how my old style was bad, and for giving advices on how to improve it. Thanks to John van de Wetering, whose style has also been a source of inspiration.

\printindex


\end{document}
